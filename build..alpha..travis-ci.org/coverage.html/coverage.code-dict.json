{"/home/travis/build/npmtest/node-npmtest-gl/test.js":"/* istanbul instrument in package npmtest_gl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gl/lib.npmtest_gl.js":"/* istanbul instrument in package npmtest_gl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_gl = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_gl = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-gl/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-gl && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_gl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_gl\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_gl.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_gl.rollup.js'] =\n            local.assetsDict['/assets.npmtest_gl.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_gl.__dirname +\n                    '/lib.npmtest_gl.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/gl/index.js":"if (typeof WebGLRenderingContext !== 'undefined') {\n  module.exports = require('./browser_index')\n} else {\n  module.exports = require('./node_index')\n}\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/gl/node_index.js":"var bits = require('bit-twiddle')\nvar webgl = require('./webgl')\nvar wrap = require('./wrap')\n\nvar CONTEXT_COUNTER = 0\n\nfunction flag (options, name, dflt) {\n  if (!options || !(typeof options === 'object') || !(name in options)) {\n    return dflt\n  }\n  return !!options[name]\n}\n\nfunction createContext (width, height, options) {\n  var i\n\n  width = width | 0\n  height = height | 0\n  if (!(width > 0 && height > 0)) {\n    return null\n  }\n\n  var contextAttributes = new webgl.WebGLContextAttributes(\n    flag(options, 'alpha', true),\n    flag(options, 'depth', true),\n    flag(options, 'stencil', false),\n    false, // flag(options, 'antialias', true),\n    flag(options, 'premultipliedAlpha', true),\n    flag(options, 'preserveDrawingBuffer', false),\n    flag(options, 'preferLowPowerToHighPerformance', false),\n    flag(options, 'failIfMajorPerformanceCaveat', false))\n\n  // Can only use premultipliedAlpha if alpha is set\n  contextAttributes.premultipliedAlpha =\n    contextAttributes.premultipliedAlpha && contextAttributes.alpha\n\n  var gl\n  try {\n    gl = new webgl.WebGLRenderingContext(\n      1,\n      1,\n      contextAttributes.alpha,\n      contextAttributes.depth,\n      contextAttributes.stencil,\n      contextAttributes.antialias,\n      contextAttributes.premultipliedAlpha,\n      contextAttributes.preserveDrawingBuffer,\n      contextAttributes.preferLowPowerToHighPerformance,\n      contextAttributes.failIfMajorPerformanceCaveat)\n  } catch (e) {}\n  if (!gl) {\n    return null\n  }\n\n  gl.drawingBufferWidth = width\n  gl.drawingBufferHeight = height\n\n  gl._ = CONTEXT_COUNTER++\n\n  gl._contextattributes = contextAttributes\n\n  gl._extensions = {}\n  gl._programs = {}\n  gl._shaders = {}\n  gl._buffers = {}\n  gl._textures = {}\n  gl._framebuffers = {}\n  gl._renderbuffers = {}\n\n  gl._activeProgram = null\n  gl._activeFramebuffer = null\n  gl._activeArrayBuffer = null\n  gl._activeElementArrayBuffer = null\n  gl._activeRenderbuffer = null\n\n  // Initialize texture units\n  var numTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n  gl._textureUnits = new Array(numTextures)\n  for (i = 0; i < numTextures; ++i) {\n    gl._textureUnits[i] = new webgl.WebGLTextureUnit(i)\n  }\n  gl._activeTextureUnit = 0\n  gl.activeTexture(gl.TEXTURE0)\n\n  gl._errorStack = []\n\n  // Initialize vertex attributes\n  var numAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)\n  gl._vertexAttribs = new Array(numAttribs)\n  for (i = 0; i < numAttribs; ++i) {\n    gl._vertexAttribs[i] = new webgl.WebGLVertexAttribute(gl, i)\n  }\n\n  // Store limits\n  gl._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)\n  gl._maxTextureLevel = bits.log2(bits.nextPow2(gl._maxTextureSize))\n  gl._maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)\n  gl._maxCubeMapLevel = bits.log2(bits.nextPow2(gl._maxCubeMapSize))\n\n  // Unpack alignment\n  gl._unpackAlignment = 4\n  gl._packAlignment = 4\n\n  // Allocate framebuffer\n  webgl.allocateDrawingBuffer(gl, width, height)\n\n  var attrib0Buffer = gl.createBuffer()\n  gl._attrib0Buffer = attrib0Buffer\n\n  // Initialize defaults\n  gl.bindBuffer(gl.ARRAY_BUFFER, null)\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n  gl.bindRenderbuffer(gl.RENDERBUFFER, null)\n\n  // Set viewport and scissor\n  gl.viewport(0, 0, width, height)\n  gl.scissor(0, 0, width, height)\n\n  // Clear buffers\n  gl.clearDepth(1)\n  gl.clearColor(0, 0, 0, 0)\n  gl.clearStencil(0)\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)\n\n  return wrap(gl)\n}\n\nmodule.exports = createContext\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/gl/webgl.js":"'use strict'\n\nvar bits = require('bit-twiddle')\nvar nativeGL = require('bindings')('webgl')\nvar tokenize = require('glsl-tokenizer/string')\n\nvar HEADLESS_VERSION = require('./package.json').version\n\n// These are defined by the WebGL spec\nvar MAX_UNIFORM_LENGTH = 256\nvar MAX_ATTRIBUTE_LENGTH = 256\n\n// We need to wrap some of the native WebGL functions to handle certain error codes and check input values\nvar gl = nativeGL.WebGLRenderingContext.prototype\ngl.VERSION = 0x1F02\ngl.IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A\ngl.IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B\n\nvar ATTACHMENTS = [\n  gl.COLOR_ATTACHMENT0,\n  gl.DEPTH_ATTACHMENT,\n  gl.STENCIL_ATTACHMENT,\n  gl.DEPTH_STENCIL_ATTACHMENT\n]\n\n// Hook clean up\nprocess.on('exit', nativeGL.cleanup)\n\n// Export type boxes for WebGL\nexports.WebGLRenderingContext = nativeGL.WebGLRenderingContext\n\nfunction WebGLProgram (_, ctx) {\n  this._ = _\n  this._ctx = ctx\n  this._linkCount = 0\n  this._pendingDelete = false\n  this._linkStatus = false\n  this._linkInfoLog = 'not linked'\n  this._references = []\n  this._refCount = 0\n  this._attributes = []\n  this._uniforms = []\n}\nexports.WebGLProgram = WebGLProgram\n\nfunction WebGLShader (_, ctx, type) {\n  this._ = _\n  this._type = type\n  this._ctx = ctx\n  this._pendingDelete = false\n  this._references = []\n  this._refCount = 0\n  this._source = ''\n  this._compileStatus = false\n  this._compileInfo = ''\n}\nexports.WebGLShader = WebGLShader\n\nfunction WebGLBuffer (_, ctx) {\n  this._ = _\n  this._ctx = ctx\n  this._binding = 0\n  this._size = 0\n  this._pendingDelete = false\n  this._references = []\n  this._refCount = 0\n  this._elements = new Uint8Array(0)\n}\nexports.WebGLBuffer = WebGLBuffer\n\nfunction WebGLFramebuffer (_, ctx) {\n  this._ = _\n  this._ctx = ctx\n  this._binding = 0\n  this._pendingDelete = false\n  this._references = []\n  this._refCount = 0\n\n  this._width = 0\n  this._height = 0\n\n  this._attachments = {}\n  this._attachments[gl.COLOR_ATTACHMENT0] = null\n  this._attachments[gl.DEPTH_ATTACHMENT] = null\n  this._attachments[gl.STENCIL_ATTACHMENT] = null\n  this._attachments[gl.DEPTH_STENCIL_ATTACHMENT] = null\n\n  this._attachmentLevel = {}\n  this._attachmentLevel[gl.COLOR_ATTACHMENT0] = 0\n  this._attachmentLevel[gl.DEPTH_ATTACHMENT] = 0\n  this._attachmentLevel[gl.STENCIL_ATTACHMENT] = 0\n  this._attachmentLevel[gl.DEPTH_STENCIL_ATTACHMENT] = 0\n\n  this._attachmentFace = {}\n  this._attachmentFace[gl.COLOR_ATTACHMENT0] = 0\n  this._attachmentFace[gl.DEPTH_ATTACHMENT] = 0\n  this._attachmentFace[gl.STENCIL_ATTACHMENT] = 0\n  this._attachmentFace[gl.DEPTH_STENCIL_ATTACHMENT] = 0\n}\nexports.WebGLFramebuffer = WebGLFramebuffer\n\nfunction WebGLRenderbuffer (_, ctx) {\n  this._ = _\n  this._ctx = ctx\n  this._binding = 0\n  this._pendingDelete = false\n  this._references = []\n  this._refCount = 0\n  this._width = 0\n  this._height = 0\n  this._format = 0\n}\nexports.WebGLRenderbuffer = WebGLRenderbuffer\n\nfunction WebGLTexture (_, ctx) {\n  this._ = _\n  this._ctx = ctx\n  this._binding = 0\n  this._pendingDelete = false\n  this._references = []\n  this._refCount = 0\n  this._levelWidth = new Int32Array(32)\n  this._levelHeight = new Int32Array(32)\n  this._format = 0\n  this._type = 0\n}\nexports.WebGLTexture = WebGLTexture\n\nfunction WebGLActiveInfo (_) {\n  this.size = _.size\n  this.type = _.type\n  this.name = _.name\n}\nexports.WebGLActiveInfo = WebGLActiveInfo\n\nfunction WebGLShaderPrecisionFormat (_) {\n  this.rangeMin = _.rangeMin\n  this.rangeMax = _.rangeMax\n  this.precision = _.precision\n}\nexports.WebGLShaderPrecisionFormat = WebGLShaderPrecisionFormat\n\nfunction WebGLUniformLocation (_, program, info) {\n  this._ = _\n  this._program = program\n  this._linkCount = program._linkCount\n  this._activeInfo = info\n  this._array = null\n}\nexports.WebGLUniformLocation = WebGLUniformLocation\n\nfunction WebGLContextAttributes (\n  alpha,\n  depth,\n  stencil,\n  antialias,\n  premultipliedAlpha,\n  preserveDrawingBuffer,\n  preferLowPowerToHighPerformance,\n  failIfMajorPerformanceCaveat) {\n  this.alpha = alpha\n  this.depth = depth\n  this.stencil = stencil\n  this.antialias = antialias\n  this.premultipliedAlpha = premultipliedAlpha\n  this.preserveDrawingBuffer = preserveDrawingBuffer\n  this.preferLowPowerToHighPerformance = preferLowPowerToHighPerformance\n  this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat\n}\nexports.WebGLContextAttributes = WebGLContextAttributes\n\nfunction WebGLVertexAttribute (ctx, idx) {\n  this._ctx = ctx\n  this._idx = idx\n  this._isPointer = false\n  this._pointerBuffer = null\n  this._pointerOffset = 0\n  this._pointerSize = 0\n  this._pointerStride = 0\n  this._pointerType = gl.FLOAT\n  this._pointerNormal = false\n  this._divisor = 0\n  this._inputSize = 4\n  this._inputStride = 0\n  this._data = new Float32Array([0, 0, 0, 1])\n}\nexports.WebGLVertexAttribute = WebGLVertexAttribute\n\nfunction WebGLTextureUnit (ctx, idx) {\n  this._ctx = ctx\n  this._idx = idx\n  this._mode = 0\n  this._bind2D = null\n  this._bindCube = null\n}\nexports.WebGLTextureUnit = WebGLTextureUnit\n\nfunction WebGLDrawingBufferWrapper (\n  framebuffer,\n  color,\n  depthStencil) {\n  this._framebuffer = framebuffer\n  this._color = color\n  this._depthStencil = depthStencil\n}\nexports.WebGLDrawingBufferWrapper = WebGLDrawingBufferWrapper\n\nfunction ANGLE_instanced_arrays () {\n}\n\nfunction STACKGL_resize_drawingbuffer () {\n}\n\nfunction STACKGL_destroy_context () {\n}\n\nfunction unpackTypedArray (array) {\n  return (new Uint8Array(array.buffer)).subarray(\n    array.byteOffset,\n    array.byteLength + array.byteOffset)\n}\n\n// Don't allow: \", $, `, @, \\, ', \\0\nfunction isValidString (str) {\n  // Remove comments first\n  var c = str.replace(/(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm, '')\n  return !(/[\\\"\\$\\`\\@\\\\\\'\\0]/.test(c))\n}\n\nfunction isTypedArray (data) {\n  return data instanceof Uint8Array ||\n  data instanceof Uint8ClampedArray ||\n  data instanceof Int8Array ||\n  data instanceof Uint16Array ||\n  data instanceof Int16Array ||\n  data instanceof Uint32Array ||\n  data instanceof Int32Array ||\n  data instanceof Float32Array ||\n  data instanceof Float64Array\n}\n\nfunction activeTextureUnit (context) {\n  return context._textureUnits[context._activeTextureUnit]\n}\n\nfunction activeTexture (context, target) {\n  var activeUnit = activeTextureUnit(context)\n  if (target === gl.TEXTURE_2D) {\n    return activeUnit._bind2D\n  } else if (target === gl.TEXTURE_CUBE_MAP) {\n    return activeUnit._bindCube\n  }\n  return null\n}\n\nfunction validCubeTarget (target) {\n  return target === gl.TEXTURE_CUBE_MAP_POSITIVE_X ||\n  target === gl.TEXTURE_CUBE_MAP_NEGATIVE_X ||\n  target === gl.TEXTURE_CUBE_MAP_POSITIVE_Y ||\n  target === gl.TEXTURE_CUBE_MAP_NEGATIVE_Y ||\n  target === gl.TEXTURE_CUBE_MAP_POSITIVE_Z ||\n  target === gl.TEXTURE_CUBE_MAP_NEGATIVE_Z\n}\n\nfunction precheckFramebufferStatus (framebuffer) {\n  var attachments = framebuffer._attachments\n  var width = []\n  var height = []\n\n  var colorAttachment = attachments[gl.COLOR_ATTACHMENT0]\n  var depthAttachment = attachments[gl.DEPTH_ATTACHMENT]\n  var depthStencilAttachment = attachments[gl.DEPTH_STENCIL_ATTACHMENT]\n  var stencilAttachment = attachments[gl.STENCIL_ATTACHMENT]\n\n  if (depthStencilAttachment && (stencilAttachment || depthAttachment) ||\n      (stencilAttachment && depthAttachment)) {\n    return gl.FRAMEBUFFER_UNSUPPORTED\n  }\n\n  if (!colorAttachment) {\n    return gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n  }\n\n  if (depthStencilAttachment instanceof WebGLTexture) {\n    return gl.FRAMEBUFFER_UNSUPPORTED\n  } else if (depthStencilAttachment instanceof WebGLRenderbuffer) {\n    if (depthStencilAttachment._format !== gl.DEPTH_STENCIL) {\n      return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    }\n    width.push(depthStencilAttachment._width)\n    height.push(depthStencilAttachment._height)\n  }\n\n  if (depthAttachment instanceof WebGLTexture) {\n    return gl.FRAMEBUFFER_UNSUPPORTED\n  } else if (depthAttachment instanceof WebGLRenderbuffer) {\n    if (depthAttachment._format !== gl.DEPTH_COMPONENT16) {\n      return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    }\n    width.push(depthAttachment._width)\n    height.push(depthAttachment._height)\n  }\n\n  if (stencilAttachment instanceof WebGLTexture) {\n    return gl.FRAMEBUFFER_UNSUPPORTED\n  } else if (stencilAttachment instanceof WebGLRenderbuffer) {\n    if (stencilAttachment._format !== gl.STENCIL_INDEX8) {\n      return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    }\n    width.push(stencilAttachment._width)\n    height.push(stencilAttachment._height)\n  }\n\n  if (colorAttachment instanceof WebGLTexture) {\n    if (colorAttachment._format !== gl.RGBA ||\n        colorAttachment._type !== gl.UNSIGNED_BYTE) {\n      return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    }\n    var level = framebuffer._attachmentLevel[gl.COLOR_ATTACHMENT0]\n    width.push(colorAttachment._levelWidth[level])\n    height.push(colorAttachment._levelHeight[level])\n  } else if (colorAttachment instanceof WebGLRenderbuffer) {\n    var format = colorAttachment._format\n    if (format !== gl.RGBA4 &&\n      format !== gl.RGB565 &&\n      format !== gl.RGB5_A1) {\n      return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    }\n    width.push(colorAttachment._width)\n    height.push(colorAttachment._height)\n  }\n\n  if (!colorAttachment &&\n      !stencilAttachment &&\n      !depthAttachment &&\n      !depthStencilAttachment) {\n    return gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n  }\n\n  if (width.length <= 0 || height.length <= 0) {\n    return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n  }\n\n  for (var i = 1; i < width.length; ++i) {\n    if (width[i - 1] !== width[i] ||\n        height[i - 1] !== height[i]) {\n      return gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n    }\n  }\n\n  if (width[0] === 0 || height[0] === 0) {\n    return gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n  }\n\n  framebuffer._width = width[0]\n  framebuffer._height = height[0]\n\n  return gl.FRAMEBUFFER_COMPLETE\n}\n\nfunction framebufferOk (context) {\n  var framebuffer = context._activeFramebuffer\n  if (framebuffer &&\n    precheckFramebufferStatus(framebuffer) !== gl.FRAMEBUFFER_COMPLETE) {\n    setError(context, gl.INVALID_FRAMEBUFFER_OPERATION)\n    return false\n  }\n  return true\n}\n\nfunction getTexImage (context, target) {\n  var unit = activeTextureUnit(context)\n  if (target === gl.TEXTURE_2D) {\n    return unit._bind2D\n  } else if (validCubeTarget(target)) {\n    return unit._bindCube\n  }\n  setError(context, gl.INVALID_ENUM)\n  return null\n}\n\nfunction checkObject (object) {\n  return typeof object === 'object' ||\n  (object === void 0)\n}\n\nfunction validFramebufferAttachment (attachment) {\n  return attachment === gl.COLOR_ATTACHMENT0 ||\n  attachment === gl.DEPTH_ATTACHMENT ||\n  attachment === gl.STENCIL_ATTACHMENT ||\n  attachment === gl.DEPTH_STENCIL_ATTACHMENT\n}\n\nfunction validTextureTarget (target) {\n  return target === gl.TEXTURE_2D ||\n  target === gl.TEXTURE_CUBE_MAP\n}\n\nfunction checkTextureTarget (context, target) {\n  var unit = activeTextureUnit(context)\n  var tex = null\n  if (target === gl.TEXTURE_2D) {\n    tex = unit._bind2D\n  } else if (target === gl.TEXTURE_CUBE_MAP) {\n    tex = unit._bindCube\n  } else {\n    setError(context, gl.INVALID_ENUM)\n    return false\n  }\n  if (!tex) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  return true\n}\n\nfunction typeSize (type) {\n  switch (type) {\n    case gl.UNSIGNED_BYTE:\n    case gl.BYTE:\n      return 1\n    case gl.UNSIGNED_SHORT:\n    case gl.SHORT:\n      return 2\n    case gl.UNSIGNED_INT:\n    case gl.INT:\n    case gl.FLOAT:\n      return 4\n  }\n  return 0\n}\n\nfunction formatSize (internalformat) {\n  switch (internalformat) {\n    case gl.ALPHA:\n    case gl.LUMINANCE:\n      return 1\n    case gl.LUMINANCE_ALPHA:\n      return 2\n    case gl.RGB:\n      return 3\n    case gl.RGBA:\n      return 4\n  }\n  return 0\n}\n\nfunction vertexCount (primitive, count) {\n  switch (primitive) {\n    case gl.TRIANGLES:\n      return count - (count % 3)\n    case gl.LINES:\n      return count - (count % 2)\n    case gl.LINE_LOOP:\n    case gl.POINTS:\n      return count\n    case gl.TRIANGLE_FAN:\n    case gl.LINE_STRIP:\n      if (count < 2) {\n        return 0\n      }\n      return count\n    case gl.TRIANGLE_STRIP:\n      if (count < 3) {\n        return 0\n      }\n      return count\n    default:\n      return -1\n  }\n}\n\nfunction link (a, b) {\n  a._references.push(b)\n  b._refCount += 1\n  return true\n}\n\nfunction unlink (a, b) {\n  var idx = a._references.indexOf(b)\n  if (idx < 0) {\n    return false\n  }\n  while (idx >= 0) {\n    a._references[idx] = a._references[a._references.length - 1]\n    a._references.pop()\n    b._refCount -= 1\n    checkDelete(b)\n    idx = a._references.indexOf(b)\n  }\n  return true\n}\n\nfunction linked (a, b) {\n  return a._references.indexOf(b) >= 0\n}\n\nfunction checkDelete (obj) {\n  if (obj._refCount <= 0 &&\n    obj._pendingDelete &&\n    obj._ !== 0) {\n    while (obj._references.length > 0) {\n      unlink(obj, obj._references[0])\n    }\n    obj._performDelete()\n    obj._ = 0\n  }\n}\n\nfunction setError (context, error) {\n  nativeGL.setError.call(context, error | 0)\n}\n\nfunction checkValid (object, type) {\n  return object instanceof type && object._ !== 0\n}\n\nfunction checkOwns (context, object) {\n  return typeof object === 'object' &&\n  object._ctx === context\n}\n\nfunction checkUniform (program, location) {\n  return location instanceof WebGLUniformLocation &&\n  location._program === program &&\n  location._linkCount === program._linkCount\n}\n\nfunction checkLocation (context, location) {\n  if (!(location instanceof WebGLUniformLocation)) {\n    setError(context, gl.INVALID_VALUE)\n    return false\n  } else if (location._program._ctx !== context ||\n    location._linkCount !== location._program._linkCount) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  return true\n}\n\nfunction checkLocationActive (context, location) {\n  if (!location) {\n    return false\n  } else if (!checkLocation(context, location)) {\n    return false\n  } else if (location._program !== context._activeProgram) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  return true\n}\n\nfunction checkWrapper (context, object, wrapper) {\n  if (!checkValid(object, wrapper)) {\n    setError(context, gl.INVALID_VALUE)\n    return false\n  } else if (!checkOwns(context, object)) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  return true\n}\n\nfunction saveError (context) {\n  context._errorStack.push(context.getError())\n}\n\nfunction restoreError (context, lastError) {\n  var topError = context._errorStack.pop()\n  if (topError === gl.NO_ERROR) {\n    setError(context, lastError)\n  } else {\n    setError(context, topError)\n  }\n}\n\nfunction getActiveBuffer (context, target) {\n  if (target === gl.ARRAY_BUFFER) {\n    return context._activeArrayBuffer\n  } else if (target === gl.ELEMENT_ARRAY_BUFFER) {\n    return context._activeElementArrayBuffer\n  }\n  return null\n}\n\nfunction checkVertexAttribState (context, maxIndex) {\n  var program = context._activeProgram\n  if (!program) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  var attribs = context._vertexAttribs\n  for (var i = 0; i < attribs.length; ++i) {\n    var attrib = attribs[i]\n    if (attrib._isPointer) {\n      var buffer = attrib._pointerBuffer\n      if (!buffer) {\n        setError(context, gl.INVALID_OPERATION)\n        return false\n      }\n      if (program._attributes.indexOf(i) >= 0) {\n        var maxByte = 0\n        if (attrib._divisor) {\n          maxByte = attrib._pointerSize +\n                    attrib._pointerOffset\n        } else {\n          maxByte = attrib._pointerStride * maxIndex +\n            attrib._pointerSize +\n            attrib._pointerOffset\n        }\n        if (maxByte > buffer._size) {\n          setError(context, gl.INVALID_OPERATION)\n          return false\n        }\n      }\n    }\n  }\n  return true\n}\n\nfunction clearFramebufferAttachment (framebuffer, attachment) {\n  var object = framebuffer._attachments[attachment]\n  if (!object) {\n    return\n  }\n  framebuffer._attachments[attachment] = null\n  unlink(framebuffer, object)\n}\n\nfunction setFramebufferAttachment (framebuffer, object, attachment) {\n  var prevObject = framebuffer._attachments[attachment]\n  if (prevObject === object) {\n    return\n  }\n\n  clearFramebufferAttachment(framebuffer, attachment)\n  if (!object) {\n    return\n  }\n\n  framebuffer._attachments[attachment] = object\n  link(framebuffer, object)\n}\n\ngl.resize = function (width, height) {\n  width = width | 0\n  height = height | 0\n  if (!(width > 0 && height > 0)) {\n    throw new Error('Invalid surface dimensions')\n  } else if (width !== this.drawingBufferWidth ||\n    height !== this.drawingBufferHeight) {\n    resizeDrawingBuffer(this, width, height)\n    this.drawingBufferWidth = width\n    this.drawingBufferHeight = height\n  }\n}\n\nvar _destroy = gl.destroy\ngl.destroy = function () {\n  _destroy.call(this)\n}\n\ngl.getContextAttributes = function () {\n  return this._contextattributes\n}\n\ngl.getSupportedExtensions = function getSupportedExtensions () {\n  return [\n    'ANGLE_instanced_arrays',\n    'STACKGL_resize_drawingbuffer',\n    'STACKGL_destroy_context'\n  ]\n}\n\nfunction createANGLEInstancedArrays (context) {\n  function checkInstancedVertexAttribState (context, maxIndex, primCount) {\n    var program = context._activeProgram\n    if (!program) {\n      setError(context, gl.INVALID_OPERATION)\n      return false\n    }\n\n    var attribs = context._vertexAttribs\n    var hasZero = false\n    for (var i = 0; i < attribs.length; ++i) {\n      var attrib = attribs[i]\n      if (attrib._isPointer) {\n        var buffer = attrib._pointerBuffer\n        if (program._attributes.indexOf(i) >= 0) {\n          if (!buffer) {\n            setError(context, gl.INVALID_OPERATION)\n            return false\n          }\n          var maxByte = 0\n          if (attrib._divisor === 0) {\n            hasZero = true\n            maxByte = attrib._pointerStride * maxIndex +\n              attrib._pointerSize +\n              attrib._pointerOffset\n          } else {\n            maxByte = attrib._pointerStride * (Math.ceil(primCount / attrib._divisor) - 1) +\n              attrib._pointerSize +\n              attrib._pointerOffset\n          }\n          if (maxByte > buffer._size) {\n            setError(context, gl.INVALID_OPERATION)\n            return false\n          }\n        }\n      }\n    }\n\n    if (!hasZero) {\n      setError(context, gl.INVALID_OPERATION)\n      return false\n    }\n\n    return true\n  }\n\n  var result = new ANGLE_instanced_arrays()\n  result.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88fe\n  result.drawArraysInstancedANGLE = function (mode, first, count, primCount) {\n    mode |= 0\n    first |= 0\n    count |= 0\n    primCount |= 0\n    if (first < 0 || count < 0 || primCount < 0) {\n      setError(context, gl.INVALID_VALUE)\n      return\n    }\n    if (!checkStencilState(context)) {\n      return\n    }\n    var reducedCount = vertexCount(mode, count)\n    if (reducedCount < 0) {\n      setError(context, gl.INVALID_ENUM)\n      return\n    }\n    if (!framebufferOk(context)) {\n      return\n    }\n    if (count === 0 || primCount === 0) {\n      return\n    }\n    var maxIndex = first\n    if (count > 0) {\n      maxIndex = (count + first - 1) >>> 0\n    }\n    if (checkInstancedVertexAttribState(context, maxIndex, primCount)) {\n      return _drawArraysInstanced.call(\n        context, mode, first, reducedCount, primCount)\n    }\n  }\n  result.drawElementsInstancedANGLE = function (\n    mode, count, type, ioffset, primCount) {\n    mode |= 0\n    count |= 0\n    type |= 0\n    ioffset |= 0\n    primCount |= 0\n\n    if (count < 0 || ioffset < 0 || primCount < 0) {\n      setError(context, gl.INVALID_VALUE)\n      return\n    }\n\n    if (!checkStencilState(context)) {\n      return\n    }\n\n    var elementBuffer = context._activeElementArrayBuffer\n    if (!elementBuffer) {\n      setError(context, gl.INVALID_OPERATION)\n      return\n    }\n\n    // Unpack element data\n    var elementData = null\n    var offset = ioffset\n    if (type === gl.UNSIGNED_SHORT) {\n      if (offset % 2) {\n        setError(context, gl.INVALID_OPERATION)\n        return\n      }\n      offset >>= 1\n      elementData = new Uint16Array(elementBuffer._elements.buffer)\n    } else if (type === gl.UNSIGNED_BYTE) {\n      elementData = elementBuffer._elements\n    } else {\n      setError(context, gl.INVALID_ENUM)\n      return\n    }\n\n    var reducedCount = count\n    switch (mode) {\n      case gl.TRIANGLES:\n        if (count % 3) {\n          reducedCount -= (count % 3)\n        }\n        break\n      case gl.LINES:\n        if (count % 2) {\n          reducedCount -= (count % 2)\n        }\n        break\n      case gl.POINTS:\n        break\n      case gl.LINE_LOOP:\n      case gl.LINE_STRIP:\n        if (count < 2) {\n          setError(context, gl.INVALID_OPERATION)\n          return\n        }\n        break\n      case gl.TRIANGLE_FAN:\n      case gl.TRIANGLE_STRIP:\n        if (count < 3) {\n          setError(context, gl.INVALID_OPERATION)\n          return\n        }\n        break\n      default:\n        setError(context, gl.INVALID_ENUM)\n        return\n    }\n\n    if (!framebufferOk(context)) {\n      return\n    }\n\n    if (count === 0 || primCount === 0) {\n      checkInstancedVertexAttribState(context, 0, 0)\n      return\n    }\n\n    if ((count + offset) >>> 0 > elementData.length) {\n      setError(context, gl.INVALID_OPERATION)\n      return\n    }\n\n    // Compute max index\n    var maxIndex = -1\n    for (var i = offset; i < offset + count; ++i) {\n      maxIndex = Math.max(maxIndex, elementData[i])\n    }\n\n    if (maxIndex < 0) {\n      checkInstancedVertexAttribState(context, 0, 0)\n      return\n    }\n\n    if (checkInstancedVertexAttribState(context, maxIndex, primCount)) {\n      if (reducedCount > 0) {\n        _drawElementsInstanced.call(context, mode, reducedCount, type, ioffset, primCount)\n      }\n    }\n  }\n\n  result.vertexAttribDivisorANGLE = function (index, divisor) {\n    index |= 0\n    divisor |= 0\n    if (divisor < 0 ||\n        index < 0 || index >= context._vertexAttribs.length) {\n      setError(context, gl.INVALID_VALUE)\n      return\n    }\n    var attrib = context._vertexAttribs[index]\n    attrib._divisor = divisor\n    _vertexAttribDivisor.call(context, index, divisor)\n  }\n  return result\n}\n\ngl.getExtension = function getExtension (name) {\n  var str = name.toLowerCase()\n  if (str in this._extensions) {\n    return this._extensions[str]\n  }\n  var ext = null\n  switch (str) {\n    case 'angle_instanced_arrays':\n      ext = createANGLEInstancedArrays(this)\n      break\n    case 'stackgl_destroy_context':\n      ext = new STACKGL_destroy_context()\n      ext.destroy = this.destroy.bind(this)\n      break\n    case 'stackgl_resize_drawingbuffer':\n      ext = new STACKGL_resize_drawingbuffer()\n      ext.resize = this.resize.bind(this)\n      break\n  }\n  if (ext) {\n    this._extensions[str] = ext\n  }\n  return ext\n}\n\nvar _activeTexture = gl.activeTexture\ngl.activeTexture = function activeTexture (texture) {\n  texture |= 0\n  var texNum = texture - gl.TEXTURE0\n  if (texNum >= 0 && texNum < this._textureUnits.length) {\n    this._activeTextureUnit = texNum\n    return _activeTexture.call(this, texture)\n  }\n  setError(this, gl.INVALID_ENUM)\n}\n\nvar _attachShader = gl.attachShader\ngl.attachShader = function attachShader (program, shader) {\n  if (!checkObject(program) ||\n    !checkObject(shader)) {\n    throw new TypeError('attachShader(WebGLProgram, WebGLShader)')\n  }\n  if (!program || !shader) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  } else if (program instanceof WebGLProgram &&\n    shader instanceof WebGLShader &&\n    checkOwns(this, program) &&\n    checkOwns(this, shader)) {\n    if (!linked(program, shader)) {\n      saveError(this)\n      _attachShader.call(\n        this,\n        program._ | 0,\n        shader._ | 0)\n      var error = this.getError()\n      restoreError(this, error)\n      if (error === gl.NO_ERROR) {\n        link(program, shader)\n      }\n      return\n    }\n  }\n  setError(this, gl.INVALID_OPERATION)\n}\n\nvar _bindAttribLocation = gl.bindAttribLocation\ngl.bindAttribLocation = function bindAttribLocation (program, index, name) {\n  if (!checkObject(program) ||\n    typeof name !== 'string') {\n    throw new TypeError('bindAttribLocation(WebGLProgram, GLint, String)')\n  }\n  name += ''\n  if (!isValidString(name) || name.length > MAX_ATTRIBUTE_LENGTH) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  } else if (/^_?webgl_a/.test(name)) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    return _bindAttribLocation.call(\n      this,\n      program._ | 0,\n      index | 0,\n      name)\n  }\n}\n\nfunction switchActiveBuffer (active, buffer) {\n  if (active !== buffer) {\n    if (active) {\n      active._refCount -= 1\n      checkDelete(active)\n    }\n    if (buffer) {\n      buffer._refCount += 1\n    }\n  }\n}\n\nvar _bindBuffer = gl.bindBuffer\ngl.bindBuffer = function bindBuffer (target, buffer) {\n  target |= 0\n  if (!checkObject(buffer)) {\n    throw new TypeError('bindBuffer(GLenum, WebGLBuffer)')\n  }\n  if (target !== gl.ARRAY_BUFFER &&\n    target !== gl.ELEMENT_ARRAY_BUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (!buffer) {\n    _bindBuffer.call(this, target, 0)\n  } else if (buffer._pendingDelete) {\n    return\n  } else if (checkWrapper(this, buffer, WebGLBuffer)) {\n    if (buffer._binding && buffer._binding !== target) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n    buffer._binding = target | 0\n\n    _bindBuffer.call(this, target, buffer._ | 0)\n  } else {\n    return\n  }\n\n  if (target === gl.ARRAY_BUFFER) {\n    switchActiveBuffer(this._activeArrayBuffer, buffer)\n    this._activeArrayBuffer = buffer\n  } else {\n    switchActiveBuffer(this._activeElementArrayBuffer, buffer)\n    this._activeElementArrayBuffer = buffer\n  }\n}\n\nvar _bindRenderbuffer = gl.bindRenderbuffer\ngl.bindRenderbuffer = function (target, object) {\n  if (!checkObject(object)) {\n    throw new TypeError('bindRenderbuffer(GLenum, WebGLRenderbuffer)')\n  }\n\n  if (target !== gl.RENDERBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (!object) {\n    _bindRenderbuffer.call(\n      this,\n      target | 0,\n      0)\n  } else if (object._pendingDelete) {\n    return\n  } else if (checkWrapper(this, object, WebGLRenderbuffer)) {\n    _bindRenderbuffer.call(\n      this,\n      target | 0,\n      object._ | 0)\n  } else {\n    return\n  }\n  var active = this._activeRenderbuffer\n  if (active !== object) {\n    if (active) {\n      active._refCount -= 1\n      checkDelete(active)\n    }\n    if (object) {\n      object._refCount += 1\n    }\n  }\n  this._activeRenderbuffer = object\n}\n\nvar _bindFramebuffer = gl.bindFramebuffer\ngl.bindFramebuffer = function bindFramebuffer (target, framebuffer) {\n  if (!checkObject(framebuffer)) {\n    throw new TypeError('bindFramebuffer(GLenum, WebGLFramebuffer)')\n  }\n  if (target !== gl.FRAMEBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n  if (!framebuffer) {\n    _bindFramebuffer.call(\n      this,\n      gl.FRAMEBUFFER,\n      this._drawingBuffer._framebuffer)\n  } else if (framebuffer._pendingDelete) {\n    return\n  } else if (checkWrapper(this, framebuffer, WebGLFramebuffer)) {\n    _bindFramebuffer.call(\n      this,\n      gl.FRAMEBUFFER,\n      framebuffer._ | 0)\n  } else {\n    return\n  }\n  var activeFramebuffer = this._activeFramebuffer\n  if (activeFramebuffer !== framebuffer) {\n    if (activeFramebuffer) {\n      activeFramebuffer._refCount -= 1\n      checkDelete(activeFramebuffer)\n    }\n    if (framebuffer) {\n      framebuffer._refCount += 1\n    }\n  }\n  this._activeFramebuffer = framebuffer\n  if (framebuffer) {\n    updateFramebufferAttachments(framebuffer)\n  }\n}\n\nvar _bindTexture = gl.bindTexture\ngl.bindTexture = function bindTexture (target, texture) {\n  target |= 0\n\n  if (!checkObject(texture)) {\n    throw new TypeError('bindTexture(GLenum, WebGLTexture)')\n  }\n\n  if (!validTextureTarget(target)) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  // Get texture id\n  var texture_id = 0\n  if (!texture) {\n    texture = null\n  } else if (texture instanceof WebGLTexture &&\n    texture._pendingDelete) {\n    // Special case: error codes for deleted textures don't get set for some dumb reason\n    return\n  } else if (checkWrapper(this, texture, WebGLTexture)) {\n    // Check binding mode of texture\n    if (texture._binding && texture._binding !== target) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n    texture._binding = target\n\n    texture_id = texture._ | 0\n  } else {\n    return\n  }\n\n  saveError(this)\n  _bindTexture.call(\n    this,\n    target,\n    texture_id)\n  var error = this.getError()\n  restoreError(this, error)\n\n  if (error !== gl.NO_ERROR) {\n    return\n  }\n\n  var activeUnit = activeTextureUnit(this)\n  var activeTex = activeTexture(this, target)\n\n  // Update references\n  if (activeTex !== texture) {\n    if (activeTex) {\n      activeTex._refCount -= 1\n      checkDelete(activeTex)\n    }\n    if (texture) {\n      texture._refCount += 1\n    }\n  }\n\n  if (target === gl.TEXTURE_2D) {\n    activeUnit._bind2D = texture\n  } else if (target === gl.TEXTURE_CUBE_MAP) {\n    activeUnit._bindCube = texture\n  }\n}\n\nvar _blendColor = gl.blendColor\ngl.blendColor = function blendColor (red, green, blue, alpha) {\n  return _blendColor.call(this, +red, +green, +blue, +alpha)\n}\n\nfunction validBlendMode (mode) {\n  return mode === gl.FUNC_ADD ||\n  mode === gl.FUNC_SUBTRACT ||\n  mode === gl.FUNC_REVERSE_SUBTRACT\n}\n\nvar _blendEquation = gl.blendEquation\ngl.blendEquation = function blendEquation (mode) {\n  mode |= 0\n  if (validBlendMode(mode)) {\n    return _blendEquation.call(this, mode)\n  }\n  setError(this, gl.INVALID_ENUM)\n}\n\nvar _blendEquationSeparate = gl.blendEquationSeparate\ngl.blendEquationSeparate = function blendEquationSeparate (modeRGB, modeAlpha) {\n  modeRGB |= 0\n  modeAlpha |= 0\n  if (validBlendMode(modeRGB) && validBlendMode(modeAlpha)) {\n    return _blendEquationSeparate.call(this, modeRGB, modeAlpha)\n  }\n  setError(this, gl.INVALID_ENUM)\n}\n\nfunction validBlendFunc (factor) {\n  return factor === gl.ZERO ||\n    factor === gl.ONE ||\n    factor === gl.SRC_COLOR ||\n    factor === gl.ONE_MINUS_SRC_COLOR ||\n    factor === gl.DST_COLOR ||\n    factor === gl.ONE_MINUS_DST_COLOR ||\n    factor === gl.SRC_ALPHA ||\n    factor === gl.ONE_MINUS_SRC_ALPHA ||\n    factor === gl.DST_ALPHA ||\n    factor === gl.ONE_MINUS_DST_ALPHA ||\n    factor === gl.SRC_ALPHA_SATURATE ||\n    factor === gl.CONSTANT_COLOR ||\n    factor === gl.ONE_MINUS_CONSTANT_COLOR ||\n    factor === gl.CONSTANT_ALPHA ||\n    factor === gl.ONE_MINUS_CONSTANT_ALPHA\n}\n\nfunction isConstantBlendFunc (factor) {\n  return (\n    factor === gl.CONSTANT_COLOR ||\n    factor === gl.ONE_MINUS_CONSTANT_COLOR ||\n    factor === gl.CONSTANT_ALPHA ||\n    factor === gl.ONE_MINUS_CONSTANT_ALPHA)\n}\n\nvar _blendFunc = gl.blendFunc\ngl.blendFunc = function blendFunc (sfactor, dfactor) {\n  sfactor |= 0\n  dfactor |= 0\n  if (!validBlendFunc(sfactor) ||\n    !validBlendFunc(dfactor)) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n  if (isConstantBlendFunc(sfactor) && isConstantBlendFunc(dfactor)) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n  _blendFunc.call(this, sfactor, dfactor)\n}\n\nvar _blendFuncSeparate = gl.blendFuncSeparate\ngl.blendFuncSeparate = function blendFuncSeparate (\n  srcRGB,\n  dstRGB,\n  srcAlpha,\n  dstAlpha) {\n  srcRGB |= 0\n  dstRGB |= 0\n  srcAlpha |= 0\n  dstAlpha |= 0\n\n  if (!(validBlendFunc(srcRGB) &&\n        validBlendFunc(dstRGB) &&\n        validBlendFunc(srcAlpha) &&\n        validBlendFunc(dstAlpha))) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if ((isConstantBlendFunc(srcRGB) && isConstantBlendFunc(dstRGB)) ||\n      (isConstantBlendFunc(srcAlpha) && isConstantBlendFunc(dstAlpha))) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  _blendFuncSeparate.call(\n    this,\n    srcRGB,\n    dstRGB,\n    srcAlpha,\n    dstAlpha)\n}\n\nvar _bufferData = gl.bufferData\ngl.bufferData = function bufferData (target, data, usage) {\n  target |= 0\n  usage |= 0\n  if (usage !== gl.STREAM_DRAW &&\n    usage !== gl.STATIC_DRAW &&\n    usage !== gl.DYNAMIC_DRAW) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (target !== gl.ARRAY_BUFFER &&\n    target !== gl.ELEMENT_ARRAY_BUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var active = getActiveBuffer(this, target)\n  if (!active) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (typeof data === 'object') {\n    var u8Data = null\n    if (isTypedArray(data)) {\n      u8Data = unpackTypedArray(data)\n    } else if (data instanceof ArrayBuffer) {\n      u8Data = new Uint8Array(data)\n    } else {\n      setError(this, gl.INVALID_VALUE)\n      return\n    }\n\n    saveError(this)\n    _bufferData.call(\n      this,\n      target,\n      u8Data,\n      usage)\n    var error = this.getError()\n    restoreError(this, error)\n    if (error !== gl.NO_ERROR) {\n      return\n    }\n\n    active._size = u8Data.length\n    if (target === gl.ELEMENT_ARRAY_BUFFER) {\n      active._elements = new Uint8Array(u8Data)\n    }\n\n    return\n  } else if (typeof data === 'number') {\n    var size = data | 0\n    if (size < 0) {\n      setError(this, gl.INVALID_VALUE)\n      return\n    }\n\n    saveError(this)\n    _bufferData.call(\n      this,\n      target,\n      size,\n      usage)\n    error = this.getError()\n    restoreError(this, error)\n    if (error !== gl.NO_ERROR) {\n      return\n    }\n\n    active._size = size\n    if (target === gl.ELEMENT_ARRAY_BUFFER) {\n      active._elements = new Uint8Array(size)\n    }\n\n    return\n  } else {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n}\n\nvar _bufferSubData = gl.bufferSubData\ngl.bufferSubData = function bufferSubData (target, offset, data) {\n  target |= 0\n  offset |= 0\n\n  if (target !== gl.ARRAY_BUFFER &&\n    target !== gl.ELEMENT_ARRAY_BUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (data === null) {\n    return\n  }\n\n  if (!data || typeof data !== 'object') {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  var active = getActiveBuffer(this, target)\n  if (!active) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (offset < 0 || offset >= active._size) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  var u8Data = null\n  if (isTypedArray(data)) {\n    u8Data = unpackTypedArray(data)\n  } else if (data instanceof ArrayBuffer) {\n    u8Data = new Uint8Array(data)\n  } else {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (offset + u8Data.length > active._size) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (target === gl.ELEMENT_ARRAY_BUFFER) {\n    active._elements.set(u8Data, offset)\n  }\n\n  _bufferSubData.call(\n    this,\n    target,\n    offset,\n    u8Data)\n}\n\ngl.checkFramebufferStatus = function checkFramebufferStatus (target) {\n  if (target !== gl.FRAMEBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return 0\n  }\n\n  var framebuffer = this._activeFramebuffer\n  if (!framebuffer) {\n    return gl.FRAMEBUFFER_COMPLETE\n  }\n\n  return precheckFramebufferStatus(framebuffer)\n}\n\nvar _clear = gl.clear\ngl.clear = function clear (mask) {\n  if (!framebufferOk(this)) {\n    return\n  }\n  return _clear.call(this, mask | 0)\n}\n\nvar _clearColor = gl.clearColor\ngl.clearColor = function clearColor (red, green, blue, alpha) {\n  return _clearColor.call(this, +red, +green, +blue, +alpha)\n}\n\nvar _clearDepth = gl.clearDepth\ngl.clearDepth = function clearDepth (depth) {\n  return _clearDepth.call(this, +depth)\n}\n\nvar _clearStencil = gl.clearStencil\ngl.clearStencil = function clearStencil (s) {\n  return _clearStencil.call(this, s | 0)\n}\n\nvar _colorMask = gl.colorMask\ngl.colorMask = function colorMask (red, green, blue, alpha) {\n  return _colorMask.call(this, !!red, !!green, !!blue, !!alpha)\n}\n\nvar _compileShader = gl.compileShader\n\nfunction validGLSLIdentifier (str) {\n  if (str.indexOf('webgl_') === 0 ||\n    str.indexOf('_webgl_') === 0 ||\n    str.length > 256) {\n    return false\n  }\n  return true\n}\n\nfunction checkShaderSource (context, shader) {\n  var source = shader._source\n  var tokens = tokenize(source)\n\n  var errorStatus = false\n  var errorLog = []\n\n  for (var i = 0; i < tokens.length; ++i) {\n    var tok = tokens[i]\n    switch (tok.type) {\n      case 'ident':\n        if (!validGLSLIdentifier(tok.data)) {\n          errorStatus = true\n          errorLog.push(tok.line + ':' + tok.column +\n            ' invalid identifier - ' + tok.data)\n        }\n        break\n      case 'preprocessor':\n        var bodyToks = tokenize(tok.data.match(/^\\s*\\#\\s*(.*)$/)[1])\n        for (var j = 0; j < bodyToks.length; ++j) {\n          var btok = bodyToks[j]\n          if (btok.type === 'ident' || btok.type === void 0) {\n            if (!validGLSLIdentifier(btok.data)) {\n              errorStatus = true\n              errorLog.push(tok.line + ':' + btok.column +\n                ' invalid identifier - ' + btok.data)\n            }\n          }\n        }\n        break\n      case 'keyword':\n        switch (tok.data) {\n          case 'do':\n            errorStatus = true\n            errorLog.push(tok.line + ':' + tok.column + ' do not supported')\n            break\n        }\n        break\n    }\n  }\n\n  if (errorStatus) {\n    shader._compileInfo = errorLog.join('\\n')\n  }\n  return !errorStatus\n}\n\ngl.compileShader = function compileShader (shader) {\n  if (!checkObject(shader)) {\n    throw new TypeError('compileShader(WebGLShader)')\n  }\n  if (checkWrapper(this, shader, WebGLShader) &&\n    checkShaderSource(this, shader)) {\n    var prevError = this.getError()\n    _compileShader.call(this, shader._ | 0)\n    var error = this.getError()\n    shader._compileStatus = !!_getShaderParameter.call(\n        this,\n        shader._ | 0,\n        gl.COMPILE_STATUS)\n    shader._compileInfo = _getShaderInfoLog.call(\n      this,\n      shader._ | 0)\n    this.getError()\n    setError(this, prevError || error)\n  }\n}\n\nvar _copyTexImage2D = gl.copyTexImage2D\ngl.copyTexImage2D = function copyTexImage2D (\n  target,\n  level,\n  internalformat,\n  x, y, width, height,\n  border) {\n  target |= 0\n  level |= 0\n  internalformat |= 0\n  x |= 0\n  y |= 0\n  width |= 0\n  height |= 0\n  border |= 0\n\n  var texture = getTexImage(this, target)\n  if (!texture) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (internalformat !== gl.RGBA &&\n      internalformat !== gl.RGB &&\n      internalformat !== gl.ALPHA &&\n      internalformat !== gl.LUMINANCE &&\n      internalformat !== gl.LUMINANCE_ALPHA) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (level < 0 || width < 0 || height < 0 || border !== 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (level > 0 && !(bits.isPow2(width) && bits.isPow2(height))) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  saveError(this)\n  _copyTexImage2D.call(\n    this,\n    target,\n    level,\n    internalformat,\n    x,\n    y,\n    width,\n    height,\n    border)\n  var error = this.getError()\n  restoreError(this, error)\n\n  if (error === gl.NO_ERROR) {\n    texture._levelWidth[level] = width\n    texture._levelHeight[level] = height\n    texture._format = gl.RGBA\n    texture._type = gl.UNSIGNED_BYTE\n  }\n}\n\nvar _copyTexSubImage2D = gl.copyTexSubImage2D\ngl.copyTexSubImage2D = function copyTexSubImage2D (\n  target,\n  level,\n  xoffset, yoffset,\n  x, y, width, height) {\n  target |= 0\n  level |= 0\n  xoffset |= 0\n  yoffset |= 0\n  x |= 0\n  y |= 0\n  width |= 0\n  height |= 0\n\n  var texture = getTexImage(this, target)\n  if (!texture) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (width < 0 || height < 0 || xoffset < 0 || yoffset < 0 || level < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  _copyTexSubImage2D.call(\n    this,\n    target,\n    level,\n    xoffset,\n    yoffset,\n    x,\n    y,\n    width,\n    height)\n}\n\nvar _cullFace = gl.cullFace\ngl.cullFace = function cullFace (mode) {\n  return _cullFace.call(this, mode | 0)\n}\n\n// Object constructor methods\nfunction createObject (method, Wrapper, refset) {\n  var native = gl[method]\n  gl[method] = function () {\n    var id = native.call(this)\n    if (id <= 0) {\n      return null\n    } else {\n      var result = new Wrapper(id, this)\n      this[refset][id] = result\n      return result\n    }\n  }\n}\n\nvar _createFramebuffer = gl.createFramebuffer\nvar _createRenderbuffer = gl.createRenderbuffer\nvar _createTexture = gl.createTexture\ncreateObject('createBuffer', WebGLBuffer, '_buffers')\ncreateObject('createFramebuffer', WebGLFramebuffer, '_framebuffers')\ncreateObject('createProgram', WebGLProgram, '_programs')\ncreateObject('createRenderbuffer', WebGLRenderbuffer, '_renderbuffers')\ncreateObject('createTexture', WebGLTexture, '_textures')\n\nvar _createShader = gl.createShader\ngl.createShader = function (type) {\n  type |= 0\n  if (type !== gl.FRAGMENT_SHADER &&\n    type !== gl.VERTEX_SHADER) {\n    setError(this, gl.INVALID_ENUM)\n    return null\n  }\n  var id = _createShader.call(this, type)\n  if (id < 0) {\n    return null\n  }\n  var result = new WebGLShader(id, this, type)\n  this._shaders[id] = result\n  return result\n}\n\n// Generic object deletion method\nfunction deleteObject (name, type, refset) {\n  var native = gl[name]\n\n  type.prototype._performDelete = function () {\n    var ctx = this._ctx\n    delete ctx[refset][this._ | 0]\n    native.call(ctx, this._ | 0)\n  }\n\n  gl[name] = function (object) {\n    if (!checkObject(object)) {\n      throw new TypeError(name + '(' + type.name + ')')\n    }\n    if (object instanceof type &&\n      checkOwns(this, object)) {\n      object._pendingDelete = true\n      checkDelete(object)\n      return\n    }\n    setError(this, gl.INVALID_OPERATION)\n  }\n}\n\ndeleteObject('deleteProgram', WebGLProgram, '_programs')\ndeleteObject('deleteShader', WebGLShader, '_shaders')\n\nvar _deleteBuffer = gl.deleteBuffer\nWebGLBuffer.prototype._performDelete = function () {\n  var ctx = this._ctx\n  delete ctx._buffers[this._ | 0]\n  _deleteBuffer.call(ctx, this._ | 0)\n}\n\ngl.deleteBuffer = function deleteBuffer (buffer) {\n  if (!checkObject(buffer) ||\n    (buffer !== null && !(buffer instanceof WebGLBuffer))) {\n    throw new TypeError('deleteBuffer(WebGLBuffer)')\n  }\n\n  if (!(buffer instanceof WebGLBuffer &&\n    checkOwns(this, buffer))) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (this._activeArrayBuffer === buffer) {\n    this.bindBuffer(gl.ARRAY_BUFFER, null)\n  }\n  if (this._activeElementArrayBuffer === buffer) {\n    this.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n  }\n\n  for (var i = 0; i < this._vertexAttribs.length; ++i) {\n    var attrib = this._vertexAttribs[i]\n    if (attrib._pointerBuffer === buffer) {\n      attrib._pointerBuffer = null\n      attrib._pointerStride = 0\n      attrib._pointerOffset = 0\n      attrib._pointerSize = 4\n      buffer._refCount -= 1\n    }\n  }\n\n  buffer._pendingDelete = true\n  checkDelete(buffer)\n}\n\nvar _deleteFramebuffer = gl.deleteFramebuffer\nWebGLFramebuffer.prototype._performDelete = function () {\n  var ctx = this._ctx\n  delete ctx._framebuffers[this._ | 0]\n  _deleteFramebuffer.call(ctx, this._ | 0)\n}\n\ngl.deleteFramebuffer = function deleteFramebuffer (framebuffer) {\n  if (!checkObject(framebuffer)) {\n    throw new TypeError('deleteFramebuffer(WebGLFramebuffer)')\n  }\n\n  if (!(framebuffer instanceof WebGLFramebuffer &&\n    checkOwns(this, framebuffer))) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (this._activeFramebuffer === framebuffer) {\n    this.bindFramebuffer(gl.FRAMEBUFFER, null)\n  }\n\n  framebuffer._pendingDelete = true\n  checkDelete(framebuffer)\n}\n\n// Need to handle textures and render buffers as a special case:\n// When a texture gets deleted, we need to do the following extra steps:\n//  1. Is it bound to the current texture unit?\n//     If so, then unbind it\n//  2. Is it attached to the active fbo?\n//     If so, then detach it\n//\n// For renderbuffers only need to do second step\n//\n// After this, proceed with the usual deletion algorithm\n//\nvar _deleteRenderbuffer = gl.deleteRenderbuffer\nWebGLRenderbuffer.prototype._performDelete = function () {\n  var ctx = this._ctx\n  delete ctx._renderbuffers[this._ | 0]\n  _deleteRenderbuffer.call(ctx, this._ | 0)\n}\n\ngl.deleteRenderbuffer = function deleteRenderbuffer (renderbuffer) {\n  if (!checkObject(renderbuffer)) {\n    throw new TypeError('deleteRenderbuffer(WebGLRenderbuffer)')\n  }\n\n  if (!(renderbuffer instanceof WebGLRenderbuffer &&\n    checkOwns(this, renderbuffer))) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (this._activeRenderbuffer === renderbuffer) {\n    this.bindRenderbuffer(gl.RENDERBUFFER, null)\n  }\n\n  var ctx = this\n  var activeFramebuffer = this._activeFramebuffer\n  function tryDetach (framebuffer) {\n    if (framebuffer && linked(framebuffer, renderbuffer)) {\n      var attachments = Object.keys(framebuffer._attachments)\n      for (var i = 0; i < attachments.length; ++i) {\n        if (framebuffer._attachments[ATTACHMENTS[i]] === renderbuffer) {\n          ctx.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            ATTACHMENTS[i] | 0,\n            gl.TEXTURE_2D,\n            null)\n        }\n      }\n    }\n  }\n\n  tryDetach(activeFramebuffer)\n\n  renderbuffer._pendingDelete = true\n  checkDelete(renderbuffer)\n}\n\nvar _deleteTexture = gl.deleteTexture\nWebGLTexture.prototype._performDelete = function () {\n  var ctx = this._ctx\n  delete ctx._textures[this._ | 0]\n  _deleteTexture.call(ctx, this._ | 0)\n}\n\ngl.deleteTexture = function deleteTexture (texture) {\n  if (!checkObject(texture)) {\n    throw new TypeError('deleteTexture(WebGLTexture)')\n  }\n\n  if (texture instanceof WebGLTexture) {\n    if (!checkOwns(this, texture)) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n  } else {\n    return\n  }\n\n  // Unbind from all texture units\n  var curActive = this._activeTextureUnit\n\n  for (var i = 0; i < this._textureUnits.length; ++i) {\n    var unit = this._textureUnits[i]\n    if (unit._bind2D === texture) {\n      this.activeTexture(gl.TEXTURE0 + i)\n      this.bindTexture(gl.TEXTURE_2D, null)\n    } else if (unit._bindCube === texture) {\n      this.activeTexture(gl.TEXTURE0 + i)\n      this.bindTexture(gl.TEXTURE_CUBE_MAP, null)\n    }\n  }\n  this.activeTexture(gl.TEXTURE0 + curActive)\n\n  // FIXME: Does the texture get unbound from *all* framebuffers, or just the\n  // active FBO?\n  var ctx = this\n  var activeFramebuffer = this._activeFramebuffer\n\n  function tryDetach (framebuffer) {\n    if (framebuffer && linked(framebuffer, texture)) {\n      for (var i = 0; i < ATTACHMENTS.length; ++i) {\n        var attachment = ATTACHMENTS[i]\n        if (framebuffer._attachments[attachment] === texture) {\n          ctx.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            attachment,\n            gl.TEXTURE_2D,\n            null)\n        }\n      }\n    }\n  }\n\n  tryDetach(activeFramebuffer)\n\n  // Mark texture for deletion\n  texture._pendingDelete = true\n\n  checkDelete(texture)\n}\n\nvar _depthFunc = gl.depthFunc\ngl.depthFunc = function depthFunc (func) {\n  func |= 0\n  switch (func) {\n    case gl.NEVER:\n    case gl.LESS:\n    case gl.EQUAL:\n    case gl.LEQUAL:\n    case gl.GREATER:\n    case gl.NOTEQUAL:\n    case gl.GEQUAL:\n    case gl.ALWAYS:\n      return _depthFunc.call(this, func)\n    default:\n      setError(this, gl.INVALID_ENUM)\n      return\n  }\n}\n\nvar _depthMask = gl.depthMask\ngl.depthMask = function depthMask (flag) {\n  return _depthMask.call(this, !!flag)\n}\n\nvar _depthRange = gl.depthRange\ngl.depthRange = function depthRange (zNear, zFar) {\n  zNear = +zNear\n  zFar = +zFar\n  if (zNear <= zFar) {\n    return _depthRange.call(this, zNear, zFar)\n  }\n  setError(this, gl.INVALID_OPERATION)\n}\n\nvar _detachShader = gl.detachShader\ngl.detachShader = function detachShader (program, shader) {\n  if (!checkObject(program) ||\n    !checkObject(shader)) {\n    throw new TypeError('detachShader(WebGLProgram, WebGLShader)')\n  }\n  if (checkWrapper(this, program, WebGLProgram) &&\n    checkWrapper(this, shader, WebGLShader)) {\n    if (linked(program, shader)) {\n      _detachShader.call(this, program._, shader._)\n      unlink(program, shader)\n    } else {\n      setError(this, gl.INVALID_OPERATION)\n    }\n  }\n}\n\nvar _disable = gl.disable\ngl.disable = function disable (cap) {\n  cap |= 0\n  _disable.call(this, cap)\n  if (cap === gl.TEXTURE_2D ||\n    cap === gl.TEXTURE_CUBE_MAP) {\n    var active = activeTextureUnit(this)\n    if (active._mode === cap) {\n      active._mode = 0\n    }\n  }\n}\n\nvar _disableVertexAttribArray = gl.disableVertexAttribArray\ngl.disableVertexAttribArray = function disableVertexAttribArray (index) {\n  index |= 0\n  if (index < 0 || index >= this._vertexAttribs.length) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n  _disableVertexAttribArray.call(this, index)\n  this._vertexAttribs[index]._isPointer = false\n}\n\nvar _vertexAttribDivisor = gl.vertexAttribDivisor\ndelete gl.vertexAttribDivisor\n\nfunction beginAttrib0Hack (context) {\n  _bindBuffer.call(context, gl.ARRAY_BUFFER, context._attrib0Buffer._)\n  _bufferData.call(\n    context,\n    gl.ARRAY_BUFFER,\n    context._vertexAttribs[0]._data,\n    gl.STREAM_DRAW)\n  _enableVertexAttribArray.call(context, 0)\n  _vertexAttribPointer.call(context, 0, 4, gl.FLOAT, false, 0, 0)\n  _vertexAttribDivisor.call(context, 0, 1)\n}\n\nfunction endAttrib0Hack (context) {\n  var attrib = context._vertexAttribs[0]\n  if (attrib._pointerBuffer) {\n    _bindBuffer.call(context, gl.ARRAY_BUFFER, attrib._pointerBuffer._)\n  } else {\n    _bindBuffer.call(context, gl.ARRAY_BUFFER, 0)\n  }\n  _vertexAttribPointer.call(context,\n    0,\n    attrib._inputSize,\n    attrib._pointerType,\n    attrib._pointerNormal,\n    attrib._inputStride,\n    attrib._pointerOffset)\n  _vertexAttribDivisor.call(context, 0, attrib._divisor)\n  _disableVertexAttribArray.call(context, 0)\n  if (context._activeArrayBuffer) {\n    _bindBuffer.call(context, gl.ARRAY_BUFFER, context._activeArrayBuffer._)\n  } else {\n    _bindBuffer.call(context, gl.ARRAY_BUFFER, 0)\n  }\n}\n\nfunction checkStencilState (context) {\n  if (context.getParameter(gl.STENCIL_WRITEMASK) !==\n    context.getParameter(gl.STENCIL_BACK_WRITEMASK) ||\n    context.getParameter(gl.STENCIL_VALUE_MASK) !==\n    context.getParameter(gl.STENCIL_BACK_VALUE_MASK) ||\n    context.getParameter(gl.STENCIL_REF) !==\n    context.getParameter(gl.STENCIL_BACK_REF)) {\n    setError(context, gl.INVALID_OPERATION)\n    return false\n  }\n  return true\n}\n\nvar _drawArrays = gl.drawArrays\nvar _drawArraysInstanced = gl.drawArraysInstanced\ndelete gl.drawArraysInstanced\ngl.drawArrays = function drawArrays (mode, first, count) {\n  mode |= 0\n  first |= 0\n  count |= 0\n\n  if (first < 0 || count < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (!checkStencilState(this)) {\n    return\n  }\n\n  var reducedCount = vertexCount(mode, count)\n  if (reducedCount < 0) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (!framebufferOk(this)) {\n    return\n  }\n\n  if (count === 0) {\n    return\n  }\n\n  var maxIndex = first\n  if (count > 0) {\n    maxIndex = (count + first - 1) >>> 0\n  }\n  if (checkVertexAttribState(this, maxIndex)) {\n    if (this._vertexAttribs[0]._isPointer) {\n      return _drawArrays.call(this, mode, first, reducedCount)\n    } else {\n      beginAttrib0Hack(this)\n      _drawArraysInstanced.call(this, mode, first, reducedCount, 1)\n      endAttrib0Hack(this)\n    }\n  }\n}\n\nvar _drawElements = gl.drawElements\nvar _drawElementsInstanced = gl.drawElementsInstanced\ndelete gl.drawElementsInstanced\ngl.drawElements = function drawElements (mode, count, type, ioffset) {\n  mode |= 0\n  count |= 0\n  type |= 0\n  ioffset |= 0\n\n  if (count < 0 || ioffset < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (!checkStencilState(this)) {\n    return\n  }\n\n  var elementBuffer = this._activeElementArrayBuffer\n  if (!elementBuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  // Unpack element data\n  var elementData = null\n  var offset = ioffset\n  if (type === gl.UNSIGNED_SHORT) {\n    if (offset % 2) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n    offset >>= 1\n    elementData = new Uint16Array(elementBuffer._elements.buffer)\n  } else if (type === gl.UNSIGNED_BYTE) {\n    elementData = elementBuffer._elements\n  } else {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var reducedCount = count\n  switch (mode) {\n    case gl.TRIANGLES:\n      if (count % 3) {\n        reducedCount -= (count % 3)\n      }\n      break\n    case gl.LINES:\n      if (count % 2) {\n        reducedCount -= (count % 2)\n      }\n      break\n    case gl.POINTS:\n      break\n    case gl.LINE_LOOP:\n    case gl.LINE_STRIP:\n      if (count < 2) {\n        setError(this, gl.INVALID_OPERATION)\n        return\n      }\n      break\n    case gl.TRIANGLE_FAN:\n    case gl.TRIANGLE_STRIP:\n      if (count < 3) {\n        setError(this, gl.INVALID_OPERATION)\n        return\n      }\n      break\n    default:\n      setError(this, gl.INVALID_ENUM)\n      return\n  }\n\n  if (!framebufferOk(this)) {\n    return\n  }\n\n  if (count === 0) {\n    checkVertexAttribState(this, 0)\n    return\n  }\n\n  if ((count + offset) >>> 0 > elementData.length) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  // Compute max index\n  var maxIndex = -1\n  for (var i = offset; i < offset + count; ++i) {\n    maxIndex = Math.max(maxIndex, elementData[i])\n  }\n\n  if (maxIndex < 0) {\n    checkVertexAttribState(this, 0)\n    return\n  }\n\n  if (checkVertexAttribState(this, maxIndex)) {\n    if (reducedCount > 0) {\n      if (this._vertexAttribs[0]._isPointer) {\n        return _drawElements.call(this, mode, reducedCount, type, ioffset)\n      } else {\n        beginAttrib0Hack(this)\n        _drawElementsInstanced.call(this, mode, reducedCount, type, ioffset, 1)\n        endAttrib0Hack(this)\n      }\n    }\n  }\n}\n\nvar _enable = gl.enable\ngl.enable = function enable (cap) {\n  cap |= 0\n  _enable.call(this, cap)\n}\n\nvar _enableVertexAttribArray = gl.enableVertexAttribArray\ngl.enableVertexAttribArray = function enableVertexAttribArray (index) {\n  index |= 0\n  if (index < 0 || index >= this._vertexAttribs.length) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  _enableVertexAttribArray.call(this, index)\n\n  this._vertexAttribs[index]._isPointer = true\n}\n\nvar _finish = gl.finish\ngl.finish = function finish () {\n  return _finish.call(this)\n}\n\nvar _flush = gl.flush\ngl.flush = function flush () {\n  return _flush.call(this)\n}\n\nfunction updateFramebufferAttachments (framebuffer) {\n  var prevStatus = framebuffer._status\n  var ctx = framebuffer._ctx\n  var i\n  var attachmentEnum\n  framebuffer._status = precheckFramebufferStatus(framebuffer)\n  if (framebuffer._status !== gl.FRAMEBUFFER_COMPLETE) {\n    if (prevStatus === gl.FRAMEBUFFER_COMPLETE) {\n      for (i = 0; i < ATTACHMENTS.length; ++i) {\n        attachmentEnum = ATTACHMENTS[i]\n        _framebufferTexture2D.call(\n          ctx,\n          gl.FRAMEBUFFER,\n          attachmentEnum,\n          framebuffer._attachmentFace[attachmentEnum],\n          0,\n          framebuffer._attachmentLevel[attachmentEnum])\n      }\n    }\n    return\n  }\n\n  for (i = 0; i < ATTACHMENTS.length; ++i) {\n    attachmentEnum = ATTACHMENTS[i]\n    _framebufferTexture2D.call(\n      ctx,\n      gl.FRAMEBUFFER,\n      attachmentEnum,\n      framebuffer._attachmentFace[attachmentEnum],\n      0,\n      framebuffer._attachmentLevel[attachmentEnum])\n  }\n\n  for (i = 0; i < ATTACHMENTS.length; ++i) {\n    attachmentEnum = ATTACHMENTS[i]\n    var attachment = framebuffer._attachments[attachmentEnum]\n    if (attachment instanceof WebGLTexture) {\n      _framebufferTexture2D.call(\n        ctx,\n        gl.FRAMEBUFFER,\n        attachmentEnum,\n        framebuffer._attachmentFace[attachmentEnum],\n        attachment._ | 0,\n        framebuffer._attachmentLevel[attachmentEnum])\n    } else if (attachment instanceof WebGLRenderbuffer) {\n      _framebufferRenderbuffer.call(\n        ctx,\n        gl.FRAMEBUFFER,\n        attachmentEnum,\n        gl.RENDERBUFFER,\n        attachment._ | 0)\n    }\n  }\n}\n\nvar _framebufferRenderbuffer = gl.framebufferRenderbuffer\ngl.framebufferRenderbuffer = function framebufferRenderbuffer (\n  target,\n  attachment,\n  renderbuffertarget,\n  renderbuffer) {\n  target = target | 0\n  attachment = attachment | 0\n  renderbuffertarget = renderbuffertarget | 0\n\n  if (!checkObject(renderbuffer)) {\n    throw new TypeError('framebufferRenderbuffer(GLenum, GLenum, GLenum, WebGLRenderbuffer)')\n  }\n\n  if (target !== gl.FRAMEBUFFER ||\n    !validFramebufferAttachment(attachment) ||\n    renderbuffertarget !== gl.RENDERBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var framebuffer = this._activeFramebuffer\n  if (!framebuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (renderbuffer && !checkWrapper(this, renderbuffer, WebGLRenderbuffer)) {\n    return\n  }\n\n  setFramebufferAttachment(framebuffer, renderbuffer, attachment)\n  updateFramebufferAttachments(framebuffer)\n}\n\nvar _framebufferTexture2D = gl.framebufferTexture2D\ngl.framebufferTexture2D = function framebufferTexture2D (\n  target,\n  attachment,\n  textarget,\n  texture,\n  level) {\n  target |= 0\n  attachment |= 0\n  textarget |= 0\n  level |= 0\n  if (!checkObject(texture)) {\n    throw new TypeError('framebufferTexture2D(GLenum, GLenum, GLenum, WebGLTexture, GLint)')\n  }\n\n  // Check parameters are ok\n  if (target !== gl.FRAMEBUFFER ||\n    !validFramebufferAttachment(attachment)) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (level !== 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  // Check object ownership\n  if (texture && !checkWrapper(this, texture, WebGLTexture)) {\n    return\n  }\n\n  // Check texture target is ok\n  if (textarget === gl.TEXTURE_2D) {\n    if (texture && texture._binding !== gl.TEXTURE_2D) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n  } else if (validCubeTarget(textarget)) {\n    if (texture && texture._binding !== gl.TEXTURE_CUBE_MAP) {\n      setError(this, gl.INVALID_OPERATION)\n      return\n    }\n  } else {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  // Check a framebuffer is actually bound\n  var framebuffer = this._activeFramebuffer\n  if (!framebuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  framebuffer._attachmentLevel[attachment] = level\n  framebuffer._attachmentFace[attachment] = textarget\n  setFramebufferAttachment(framebuffer, texture, attachment)\n  updateFramebufferAttachments(framebuffer)\n}\n\nvar _frontFace = gl.frontFace\ngl.frontFace = function frontFace (mode) {\n  return _frontFace.call(this, mode | 0)\n}\n\nvar _generateMipmap = gl.generateMipmap\ngl.generateMipmap = function generateMipmap (target) {\n  return _generateMipmap.call(this, target | 0) | 0\n}\n\nvar _getActiveAttrib = gl.getActiveAttrib\ngl.getActiveAttrib = function getActiveAttrib (program, index) {\n  if (!checkObject(program)) {\n    throw new TypeError('getActiveAttrib(WebGLProgram)')\n  } else if (!program) {\n    setError(this, gl.INVALID_VALUE)\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    var info = _getActiveAttrib.call(this, program._ | 0, index | 0)\n    if (info) {\n      return new WebGLActiveInfo(info)\n    }\n  }\n  return null\n}\n\nvar _getActiveUniform = gl.getActiveUniform\ngl.getActiveUniform = function getActiveUniform (program, index) {\n  if (!checkObject(program)) {\n    throw new TypeError('getActiveUniform(WebGLProgram, GLint)')\n  } else if (!program) {\n    setError(this, gl.INVALID_VALUE)\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    var info = _getActiveUniform.call(this, program._ | 0, index | 0)\n    if (info) {\n      return new WebGLActiveInfo(info)\n    }\n  }\n  return null\n}\n\nvar _getAttachedShaders = gl.getAttachedShaders\ngl.getAttachedShaders = function getAttachedShaders (program) {\n  if (!checkObject(program) ||\n    (typeof program === 'object' &&\n    program !== null &&\n    !(program instanceof WebGLProgram))) {\n    throw new TypeError('getAttachedShaders(WebGLProgram)')\n  }\n  if (!program) {\n    setError(this, gl.INVALID_VALUE)\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    var shaderArray = _getAttachedShaders.call(this, program._ | 0)\n    if (!shaderArray) {\n      return null\n    }\n    var unboxedShaders = new Array(shaderArray.length)\n    for (var i = 0; i < shaderArray.length; ++i) {\n      unboxedShaders[i] = this._shaders[shaderArray[i]]\n    }\n    return unboxedShaders\n  }\n  return null\n}\n\nvar _getAttribLocation = gl.getAttribLocation\ngl.getAttribLocation = function getAttribLocation (program, name) {\n  if (!checkObject(program)) {\n    throw new TypeError('getAttribLocation(WebGLProgram, String)')\n  }\n  name += ''\n  if (!isValidString(name) || name.length > MAX_ATTRIBUTE_LENGTH) {\n    setError(this, gl.INVALID_VALUE)\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    return _getAttribLocation.call(this, program._ | 0, name + '')\n  }\n  return -1\n}\n\nvar _getParameter = gl.getParameter\ngl.getParameter = function getParameter (pname) {\n  pname |= 0\n  switch (pname) {\n    case gl.ARRAY_BUFFER_BINDING:\n      return this._activeArrayBuffer\n    case gl.ELEMENT_ARRAY_BUFFER_BINDING:\n      return this._activeElementArrayBuffer\n    case gl.CURRENT_PROGRAM:\n      return this._activeProgram\n    case gl.FRAMEBUFFER_BINDING:\n      return this._activeFramebuffer\n    case gl.RENDERBUFFER_BINDING:\n      return this._activeRenderbuffer\n    case gl.TEXTURE_BINDING_2D:\n      return activeTextureUnit(this)._bind2D\n    case gl.TEXTURE_BINDING_CUBE_MAP:\n      return activeTextureUnit(this)._bindCube\n    case gl.VERSION:\n      return 'WebGL 1.0 stack-gl ' + HEADLESS_VERSION\n    case gl.VENDOR:\n      return 'stack-gl'\n    case gl.RENDERER:\n      return 'ANGLE'\n    case gl.SHADING_LANGUAGE_VERSION:\n      return 'WebGL GLSL ES 1.0 stack-gl'\n\n    case gl.COMPRESSED_TEXTURE_FORMATS:\n      return new Uint32Array(0)\n\n    // Int arrays\n    case gl.MAX_VIEWPORT_DIMS:\n    case gl.SCISSOR_BOX:\n    case gl.VIEWPORT:\n      return new Int32Array(_getParameter.call(this, pname))\n\n    // Float arrays\n    case gl.ALIASED_LINE_WIDTH_RANGE:\n    case gl.ALIASED_POINT_SIZE_RANGE:\n    case gl.DEPTH_RANGE:\n    case gl.BLEND_COLOR:\n    case gl.COLOR_CLEAR_VALUE:\n      return new Float32Array(_getParameter.call(this, pname))\n\n    case gl.COLOR_WRITEMASK:\n      return _getParameter.call(this, pname)\n\n    case gl.DEPTH_CLEAR_VALUE:\n    case gl.LINE_WIDTH:\n    case gl.POLYGON_OFFSET_FACTOR:\n    case gl.POLYGON_OFFSET_UNITS:\n    case gl.SAMPLE_COVERAGE_VALUE:\n      return +_getParameter.call(this, pname)\n\n    case gl.BLEND:\n    case gl.CULL_FACE:\n    case gl.DEPTH_TEST:\n    case gl.DEPTH_WRITEMASK:\n    case gl.DITHER:\n    case gl.POLYGON_OFFSET_FILL:\n    case gl.SAMPLE_COVERAGE_INVERT:\n    case gl.SCISSOR_TEST:\n    case gl.STENCIL_TEST:\n    case gl.UNPACK_FLIP_Y_WEBGL:\n    case gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL:\n      return !!_getParameter.call(this, pname)\n\n    case gl.ACTIVE_TEXTURE:\n    case gl.ALPHA_BITS:\n    case gl.BLEND_DST_ALPHA:\n    case gl.BLEND_DST_RGB:\n    case gl.BLEND_EQUATION_ALPHA:\n    case gl.BLEND_EQUATION_RGB:\n    case gl.BLEND_SRC_ALPHA:\n    case gl.BLEND_SRC_RGB:\n    case gl.BLUE_BITS:\n    case gl.CULL_FACE_MODE:\n    case gl.DEPTH_BITS:\n    case gl.DEPTH_FUNC:\n    case gl.FRONT_FACE:\n    case gl.GENERATE_MIPMAP_HINT:\n    case gl.GREEN_BITS:\n    case gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS:\n    case gl.MAX_CUBE_MAP_TEXTURE_SIZE:\n    case gl.MAX_FRAGMENT_UNIFORM_VECTORS:\n    case gl.MAX_RENDERBUFFER_SIZE:\n    case gl.MAX_TEXTURE_IMAGE_UNITS:\n    case gl.MAX_TEXTURE_SIZE:\n    case gl.MAX_VARYING_VECTORS:\n    case gl.MAX_VERTEX_ATTRIBS:\n    case gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS:\n    case gl.MAX_VERTEX_UNIFORM_VECTORS:\n    case gl.PACK_ALIGNMENT:\n    case gl.RED_BITS:\n    case gl.SAMPLE_BUFFERS:\n    case gl.SAMPLES:\n    case gl.STENCIL_BACK_FAIL:\n    case gl.STENCIL_BACK_FUNC:\n    case gl.STENCIL_BACK_PASS_DEPTH_FAIL:\n    case gl.STENCIL_BACK_PASS_DEPTH_PASS:\n    case gl.STENCIL_BACK_REF:\n    case gl.STENCIL_BACK_VALUE_MASK:\n    case gl.STENCIL_BACK_WRITEMASK:\n    case gl.STENCIL_BITS:\n    case gl.STENCIL_CLEAR_VALUE:\n    case gl.STENCIL_FAIL:\n    case gl.STENCIL_FUNC:\n    case gl.STENCIL_PASS_DEPTH_FAIL:\n    case gl.STENCIL_PASS_DEPTH_PASS:\n    case gl.STENCIL_REF:\n    case gl.STENCIL_VALUE_MASK:\n    case gl.STENCIL_WRITEMASK:\n    case gl.SUBPIXEL_BITS:\n    case gl.UNPACK_ALIGNMENT:\n    case gl.UNPACK_COLORSPACE_CONVERSION_WEBGL:\n      return _getParameter.call(this, pname) | 0\n\n    default:\n      setError(this, gl.INVALID_ENUM)\n      return null\n  }\n}\n\nvar _getShaderPrecisionFormat = gl.getShaderPrecisionFormat\ngl.getShaderPrecisionFormat = function getShaderPrecisionFormat (\n  shaderType,\n  precisionType) {\n  shaderType |= 0\n  precisionType |= 0\n\n  if (!(shaderType === gl.FRAGMENT_SHADER ||\n    shaderType === gl.VERTEX_SHADER) ||\n    !(precisionType === gl.LOW_FLOAT ||\n    precisionType === gl.MEDIUM_FLOAT ||\n    precisionType === gl.HIGH_FLOAT ||\n    precisionType === gl.LOW_INT ||\n    precisionType === gl.MEDIUM_INT ||\n    precisionType === gl.HIGH_INT)) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var format = _getShaderPrecisionFormat.call(this, shaderType, precisionType)\n  if (!format) {\n    return null\n  }\n\n  return new WebGLShaderPrecisionFormat(format)\n}\n\nvar _getBufferParameter = gl.getBufferParameter\ngl.getBufferParameter = function getBufferParameter (target, pname) {\n  target |= 0\n  pname |= 0\n  if (target !== gl.ARRAY_BUFFER &&\n    target !== gl.ELEMENT_ARRAY_BUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return null\n  }\n\n  switch (pname) {\n    case gl.BUFFER_SIZE:\n    case gl.BUFFER_USAGE:\n      return _getBufferParameter.call(this, target | 0, pname | 0)\n    default:\n      setError(this, gl.INVALID_ENUM)\n      return null\n  }\n}\n\nvar _getError = gl.getError\ngl.getError = function getError () {\n  return _getError.call(this)\n}\n\ngl.getFramebufferAttachmentParameter = function getFramebufferAttachmentParameter (target, attachment, pname) {\n  target |= 0\n  attachment |= 0\n  pname |= 0\n\n  if (target !== gl.FRAMEBUFFER ||\n    !validFramebufferAttachment(attachment)) {\n    setError(this, gl.INVALID_ENUM)\n    return null\n  }\n\n  var framebuffer = this._activeFramebuffer\n  if (!framebuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return null\n  }\n\n  var object = framebuffer._attachments[attachment]\n  if (object === null) {\n    switch (pname) {\n      case gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:\n        return gl.NONE\n    }\n  } else if (object instanceof WebGLTexture) {\n    switch (pname) {\n      case gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:\n        return object\n      case gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:\n        return gl.TEXTURE\n      case gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:\n        return framebuffer._attachmentLevel[attachment]\n      case gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:\n        var face = framebuffer._attachmentFace[attachment]\n        if (face === gl.TEXTURE_2D) {\n          return 0\n        }\n        return face\n    }\n  } else if (object instanceof WebGLRenderbuffer) {\n    switch (pname) {\n      case gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:\n        return object\n      case gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:\n        return gl.RENDERBUFFER\n    }\n  }\n\n  setError(this, gl.INVALID_ENUM)\n  return null\n}\n\nvar _getProgramParameter = gl.getProgramParameter\ngl.getProgramParameter = function getProgramParameter (program, pname) {\n  pname |= 0\n  if (!checkObject(program)) {\n    throw new TypeError('getProgramParameter(WebGLProgram, GLenum)')\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    switch (pname) {\n      case gl.DELETE_STATUS:\n        return program._pendingDelete\n\n      case gl.LINK_STATUS:\n        return program._linkStatus\n\n      case gl.VALIDATE_STATUS:\n        return !!_getProgramParameter.call(this, program._, pname)\n\n      case gl.ATTACHED_SHADERS:\n      case gl.ACTIVE_ATTRIBUTES:\n      case gl.ACTIVE_UNIFORMS:\n        return _getProgramParameter.call(this, program._, pname)\n    }\n    setError(this, gl.INVALID_ENUM)\n  }\n  return null\n}\n\nvar _getProgramInfoLog = gl.getProgramInfoLog\ngl.getProgramInfoLog = function getProgramInfoLog (program) {\n  if (!checkObject(program)) {\n    throw new TypeError('getProgramInfoLog(WebGLProgram)')\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    return program._linkInfoLog\n  }\n  return null\n}\n\nvar _getRenderbufferParameter = gl.getRenderbufferParameter\ngl.getRenderbufferParameter = function getRenderbufferParameter (target, pname) {\n  target |= 0\n  pname |= 0\n  if (target !== gl.RENDERBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return null\n  }\n  var renderbuffer = this._activeRenderbuffer\n  if (!renderbuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return null\n  }\n  switch (pname) {\n    case gl.RENDERBUFFER_INTERNAL_FORMAT:\n      return renderbuffer._format\n    case gl.RENDERBUFFER_WIDTH:\n      return renderbuffer._width\n    case gl.RENDERBUFFER_HEIGHT:\n      return renderbuffer._height\n    case gl.RENDERBUFFER_SIZE:\n    case gl.RENDERBUFFER_RED_SIZE:\n    case gl.RENDERBUFFER_GREEN_SIZE:\n    case gl.RENDERBUFFER_BLUE_SIZE:\n    case gl.RENDERBUFFER_ALPHA_SIZE:\n    case gl.RENDERBUFFER_DEPTH_SIZE:\n    case gl.RENDERBUFFER_STENCIL_SIZE:\n      return _getRenderbufferParameter.call(this, target, pname)\n  }\n  setError(this, gl.INVALID_ENUM)\n  return null\n}\n\nvar _getShaderParameter = gl.getShaderParameter\ngl.getShaderParameter = function getShaderParameter (shader, pname) {\n  pname |= 0\n  if (!checkObject(shader)) {\n    throw new TypeError('getShaderParameter(WebGLShader, GLenum)')\n  } else if (checkWrapper(this, shader, WebGLShader)) {\n    switch (pname) {\n      case gl.DELETE_STATUS:\n        return shader._pendingDelete\n      case gl.COMPILE_STATUS:\n        return shader._compileStatus\n      case gl.SHADER_TYPE:\n        return shader._type\n    }\n    setError(this, gl.INVALID_ENUM)\n  }\n  return null\n}\n\nvar _getShaderInfoLog = gl.getShaderInfoLog\ngl.getShaderInfoLog = function getShaderInfoLog (shader) {\n  if (!checkObject(shader)) {\n    throw new TypeError('getShaderInfoLog(WebGLShader)')\n  } else if (checkWrapper(this, shader, WebGLShader)) {\n    return shader._compileInfo\n  }\n  return null\n}\n\ngl.getShaderSource = function getShaderSource (shader) {\n  if (!checkObject(shader)) {\n    throw new TypeError('Input to getShaderSource must be an object')\n  } else if (checkWrapper(this, shader, WebGLShader)) {\n    return shader._source\n  }\n  return null\n}\n\nvar _getTexParameter = gl.getTexParameter\ngl.getTexParameter = function getTexParameter (target, pname) {\n  target |= 0\n  pname |= 0\n\n  if (!checkTextureTarget(this, target)) {\n    return null\n  }\n\n  var unit = activeTextureUnit(this)\n  if ((target === gl.TEXTURE_2D && !unit._bind2D) ||\n    (target === gl.TEXTURE_CUBE_MAP && !unit._bindCube)) {\n    setError(this, gl.INVALID_OPERATION)\n    return null\n  }\n\n  switch (pname) {\n    case gl.TEXTURE_MAG_FILTER:\n    case gl.TEXTURE_MIN_FILTER:\n    case gl.TEXTURE_WRAP_S:\n    case gl.TEXTURE_WRAP_T:\n      return _getTexParameter.call(this, target, pname)\n  }\n\n  setError(this, gl.INVALID_ENUM)\n  return null\n}\n\nvar _getUniform = gl.getUniform\ngl.getUniform = function getUniform (program, location) {\n  if (!checkObject(program) ||\n    !checkObject(location)) {\n    throw new TypeError('getUniform(WebGLProgram, WebGLUniformLocation)')\n  } else if (!program) {\n    setError(this, gl.INVALID_VALUE)\n    return null\n  } else if (!location) {\n    return null\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    if (!checkUniform(program, location)) {\n      setError(this, gl.INVALID_OPERATION)\n      return null\n    }\n    var data = _getUniform.call(this, program._ | 0, location._ | 0)\n    if (!data) {\n      return null\n    }\n    switch (location._activeInfo.type) {\n      case gl.FLOAT:\n        return data[0]\n      case gl.FLOAT_VEC2:\n        return new Float32Array(data.slice(0, 2))\n      case gl.FLOAT_VEC3:\n        return new Float32Array(data.slice(0, 3))\n      case gl.FLOAT_VEC4:\n        return new Float32Array(data.slice(0, 4))\n      case gl.INT:\n        return data[0] | 0\n      case gl.INT_VEC2:\n        return new Int32Array(data.slice(0, 2))\n      case gl.INT_VEC3:\n        return new Int32Array(data.slice(0, 3))\n      case gl.INT_VEC4:\n        return new Int32Array(data.slice(0, 4))\n      case gl.BOOL:\n        return !!data[0]\n      case gl.BOOL_VEC2:\n        return [!!data[0], !!data[1]]\n      case gl.BOOL_VEC3:\n        return [!!data[0], !!data[1], !!data[2]]\n      case gl.BOOL_VEC4:\n        return [!!data[0], !!data[1], !!data[2], !!data[3]]\n      case gl.FLOAT_MAT2:\n        return new Float32Array(data.slice(0, 4))\n      case gl.FLOAT_MAT3:\n        return new Float32Array(data.slice(0, 9))\n      case gl.FLOAT_MAT4:\n        return new Float32Array(data.slice(0, 16))\n      case gl.SAMPLER_2D:\n      case gl.SAMPLER_CUBE:\n        return data[0] | 0\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nvar _getUniformLocation = gl.getUniformLocation\ngl.getUniformLocation = function getUniformLocation (program, name) {\n  if (!checkObject(program)) {\n    throw new TypeError('getUniformLocation(WebGLProgram, String)')\n  }\n\n  name += ''\n  if (!isValidString(name)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (checkWrapper(this, program, WebGLProgram)) {\n    var loc = _getUniformLocation.call(this, program._ | 0, name)\n    if (loc >= 0) {\n      var searchName = name\n      if (/\\[\\d+\\]$/.test(name)) {\n        searchName = name.replace(/\\[\\d+\\]$/, '[0]')\n      }\n\n      var info = null\n      for (var i = 0; i < program._uniforms.length; ++i) {\n        var infoItem = program._uniforms[i]\n        if (infoItem.name === searchName) {\n          info = {\n            size: infoItem.size,\n            type: infoItem.type,\n            name: infoItem.name\n          }\n        }\n      }\n      if (!info) {\n        return null\n      }\n\n      var result = new WebGLUniformLocation(\n        loc,\n        program,\n        info)\n\n      // handle array case\n      if (/\\[0\\]$/.test(name)) {\n        var baseName = name.replace(/\\[0\\]$/, '')\n        var arrayLocs = []\n\n        if (offset < 0 || offset >= info.size) {\n          return null\n        }\n\n        saveError(this)\n        for (i = 0; this.getError() === gl.NO_ERROR; ++i) {\n          var xloc = _getUniformLocation.call(\n            this,\n            program._ | 0,\n            baseName + '[' + i + ']')\n          if (this.getError() !== gl.NO_ERROR || xloc < 0) {\n            break\n          }\n          arrayLocs.push(xloc)\n        }\n        restoreError(this, gl.NO_ERROR)\n\n        result._array = arrayLocs\n      } else if (/\\[(\\d+)\\]$/.test(name)) {\n        var offset = +(/\\[(\\d+)\\]$/.exec(name))[1]\n        if (offset < 0 || offset >= info.size) {\n          return null\n        }\n      }\n      return result\n    }\n  }\n  return null\n}\n\ngl.getVertexAttrib = function getVertexAttrib (index, pname) {\n  index |= 0\n  pname |= 0\n  if (index < 0 || index >= this._vertexAttribs.length) {\n    setError(this, gl.INVALID_VALUE)\n    return null\n  }\n  var attrib = this._vertexAttribs[index]\n\n  var extInstancing = this._extensions.angle_instanced_arrays\n  if (extInstancing) {\n    if (pname === extInstancing.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE) {\n      return attrib._divisor\n    }\n  }\n\n  switch (pname) {\n    case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:\n      return attrib._pointerBuffer\n    case gl.VERTEX_ATTRIB_ARRAY_ENABLED:\n      return attrib._isPointer\n    case gl.VERTEX_ATTRIB_ARRAY_SIZE:\n      return attrib._inputSize\n    case gl.VERTEX_ATTRIB_ARRAY_STRIDE:\n      return attrib._inputStride\n    case gl.VERTEX_ATTRIB_ARRAY_TYPE:\n      return attrib._pointerType\n    case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:\n      return attrib._pointerNormal\n    case gl.CURRENT_VERTEX_ATTRIB:\n      return new Float32Array(attrib._data)\n    default:\n      setError(this, gl.INVALID_ENUM)\n      return null\n  }\n}\n\ngl.getVertexAttribOffset = function getVertexAttribOffset (index, pname) {\n  index |= 0\n  pname |= 0\n  if (index < 0 || index >= this._vertexAttribs.length) {\n    setError(this, gl.INVALID_VALUE)\n    return null\n  }\n  if (pname === gl.VERTEX_ATTRIB_ARRAY_POINTER) {\n    return this._vertexAttribs[index]._pointerOffset\n  } else {\n    setError(this, gl.INVALID_ENUM)\n    return null\n  }\n}\n\nvar _hint = gl.hint\ngl.hint = function hint (target, mode) {\n  target |= 0\n  mode |= 0\n\n  if (target !== gl.GENERATE_MIPMAP_HINT) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (mode !== gl.FASTEST &&\n    mode !== gl.NICEST &&\n    mode !== gl.DONT_CARE) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  return _hint.call(this, target, mode)\n}\n\nfunction isObject (method, wrapper) {\n  var native = gl[method]\n  gl[method] = function (object) {\n    if (!(object === null || object === void 0) &&\n      !(object instanceof wrapper)) {\n      throw new TypeError(method + '(' + wrapper.name + ')')\n    }\n    if (checkValid(object, wrapper) &&\n      checkOwns(this, object)) {\n      return native.call(this, object._ | 0)\n    }\n    return false\n  }\n}\n\nisObject('isBuffer', WebGLBuffer)\nisObject('isFramebuffer', WebGLFramebuffer)\nisObject('isProgram', WebGLProgram)\nisObject('isRenderbuffer', WebGLRenderbuffer)\nisObject('isShader', WebGLShader)\nisObject('isTexture', WebGLTexture)\n\nvar _isEnabled = gl.isEnabled\ngl.isEnabled = function isEnabled (cap) {\n  return _isEnabled.call(this, cap | 0)\n}\n\nvar _lineWidth = gl.lineWidth\ngl.lineWidth = function lineWidth (width) {\n  if (isNaN(width)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n  return _lineWidth.call(this, +width)\n}\n\nvar _linkProgram = gl.linkProgram\n\nfunction fixupLink (context, program) {\n  if (!_getProgramParameter.call(context, program._, gl.LINK_STATUS)) {\n    program._linkInfoLog = _getProgramInfoLog.call(context, program)\n    return false\n  }\n\n  // Record attribute locations\n  var numAttribs = context.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)\n  var names = new Array(numAttribs)\n  program._attributes.length = numAttribs\n  for (var i = 0; i < numAttribs; ++i) {\n    names[i] = context.getActiveAttrib(program, i).name\n    program._attributes[i] = context.getAttribLocation(program, names[i]) | 0\n  }\n\n  // Check attribute names\n  for (i = 0; i < names.length; ++i) {\n    if (names[i].length > MAX_ATTRIBUTE_LENGTH) {\n      program._linkInfoLog = 'attribute ' + names[i] + ' is too long'\n      return false\n    }\n  }\n\n  for (i = 0; i < numAttribs; ++i) {\n    _bindAttribLocation.call(\n      context,\n      program._ | 0,\n      program._attributes[i],\n      names[i])\n  }\n\n  _linkProgram.call(context, program._ | 0)\n\n  var numUniforms = context.getProgramParameter(program, gl.ACTIVE_UNIFORMS)\n  program._uniforms.length = numUniforms\n  for (i = 0; i < numUniforms; ++i) {\n    program._uniforms[i] = context.getActiveUniform(program, i)\n  }\n\n  // Check attribute and uniform name lengths\n  for (i = 0; i < program._uniforms.length; ++i) {\n    if (program._uniforms[i].name.length > MAX_UNIFORM_LENGTH) {\n      program._linkInfoLog = 'uniform ' + program._uniforms[i].name + ' is too long'\n      return false\n    }\n  }\n\n  program._linkInfoLog = ''\n  return true\n}\n\ngl.linkProgram = function linkProgram (program) {\n  if (!checkObject(program)) {\n    throw new TypeError('linkProgram(WebGLProgram)')\n  }\n  if (checkWrapper(this, program, WebGLProgram)) {\n    program._linkCount += 1\n    program._attributes = []\n    var prevError = this.getError()\n    _linkProgram.call(this, program._ | 0)\n    var error = this.getError()\n    if (error === gl.NO_ERROR) {\n      program._linkStatus = fixupLink(this, program)\n    }\n    this.getError()\n    setError(this, prevError || error)\n  }\n}\n\nvar _pixelStorei = gl.pixelStorei\ngl.pixelStorei = function pixelStorei (pname, param) {\n  pname |= 0\n  param |= 0\n  if (pname === gl.UNPACK_ALIGNMENT) {\n    if (param === 1 ||\n      param === 2 ||\n      param === 4 ||\n      param === 8) {\n      this._unpackAlignment = param\n    } else {\n      setError(this, gl.INVALID_VALUE)\n      return\n    }\n  } else if (pname === gl.PACK_ALIGNMENT) {\n    if (param === 1 ||\n      param === 2 ||\n      param === 4 ||\n      param === 8) {\n      this._packAlignment = param\n    } else {\n      setError(this, gl.INVALID_VALUE)\n      return\n    }\n  } else if (pname === gl.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n    if (!(param === gl.NONE || param === gl.BROWSER_DEFAULT_WEBGL)) {\n      setError(this, gl.INVALID_VALUE)\n      return\n    }\n  }\n  return _pixelStorei.call(this, pname, param)\n}\n\nvar _polygonOffset = gl.polygonOffset\ngl.polygonOffset = function polygonOffset (factor, units) {\n  return _polygonOffset.call(this, +factor, +units)\n}\n\nvar _readPixels = gl.readPixels\ngl.readPixels = function readPixels (x, y, width, height, format, type, pixels) {\n  var i\n  var j\n  var k\n\n  x |= 0\n  y |= 0\n  width |= 0\n  height |= 0\n\n  if (format === gl.RGB ||\n    format === gl.ALPHA ||\n    type !== gl.UNSIGNED_BYTE) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  } else if (format !== gl.RGBA) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  } else if (\n    width < 0 ||\n    height < 0 ||\n    !(pixels instanceof Uint8Array)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (!framebufferOk(this)) {\n    return\n  }\n\n  var rowStride = width * 4\n  if (rowStride % this._packAlignment !== 0) {\n    rowStride += this._packAlignment - (rowStride % this._packAlignment)\n  }\n\n  var imageSize = rowStride * (height - 1) + width * 4\n  if (imageSize <= 0) {\n    return\n  }\n  if (pixels.length < imageSize) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  // Handle reading outside the window\n  var viewWidth = this.drawingBufferWidth\n  var viewHeight = this.drawingBufferHeight\n\n  if (this._activeFramebuffer) {\n    viewWidth = this._activeFramebuffer._width\n    viewHeight = this._activeFramebuffer._height\n  }\n\n  var pixelData = unpackTypedArray(pixels)\n\n  if (x >= viewWidth || x + width <= 0 ||\n    y >= viewHeight || y + height <= 0) {\n    for (i = 0; i < pixelData.length; ++i) {\n      pixelData[i] = 0\n    }\n  } else if (x < 0 || x + width > viewWidth ||\n    y < 0 || y + height > viewHeight) {\n    for (i = 0; i < pixelData.length; ++i) {\n      pixelData[i] = 0\n    }\n\n    var nx = x\n    var nwidth = width\n    if (x < 0) {\n      nwidth += x\n      nx = 0\n    }\n    if (nx + width > viewWidth) {\n      nwidth = viewWidth - nx\n    }\n    var ny = y\n    var nheight = height\n    if (y < 0) {\n      nheight += y\n      ny = 0\n    }\n    if (ny + height > viewHeight) {\n      nheight = viewHeight - ny\n    }\n\n    var nRowStride = nwidth * 4\n    if (nRowStride % this._packAlignment !== 0) {\n      nRowStride += this._packAlignment - (nRowStride % this._packAlignment)\n    }\n\n    if (nwidth > 0 && nheight > 0) {\n      var subPixels = new Uint8Array(nRowStride * nheight)\n      _readPixels.call(\n        this,\n        nx,\n        ny,\n        nwidth,\n        nheight,\n        format,\n        type,\n        subPixels)\n\n      var offset = 4 * (nx - x) + (ny - y) * rowStride\n      for (j = 0; j < nheight; ++j) {\n        for (i = 0; i < nwidth; ++i) {\n          for (k = 0; k < 4; ++k) {\n            pixelData[offset + j * rowStride + 4 * i + k] =\n              subPixels[j * nRowStride + 4 * i + k]\n          }\n        }\n      }\n    }\n  } else {\n    _readPixels.call(\n      this,\n      x,\n      y,\n      width,\n      height,\n      format,\n      type,\n      pixelData)\n  }\n}\n\nvar _renderbufferStorage = gl.renderbufferStorage\ngl.renderbufferStorage = function renderbufferStorage (\n  target,\n  internalformat,\n  width,\n  height) {\n  target |= 0\n  internalformat |= 0\n  width |= 0\n  height |= 0\n\n  if (target !== gl.RENDERBUFFER) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var renderbuffer = this._activeRenderbuffer\n  if (!renderbuffer) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (internalformat !== gl.RGBA4 &&\n      internalformat !== gl.RGB565 &&\n      internalformat !== gl.RGB5_A1 &&\n      internalformat !== gl.DEPTH_COMPONENT16 &&\n      internalformat !== gl.STENCIL_INDEX &&\n      internalformat !== gl.STENCIL_INDEX8 &&\n      internalformat !== gl.DEPTH_STENCIL) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  saveError(this)\n  _renderbufferStorage.call(\n    this,\n    target,\n    internalformat,\n    width,\n    height)\n  var error = this.getError()\n  restoreError(this, error)\n  if (error !== gl.NO_ERROR) {\n    return\n  }\n\n  renderbuffer._width = width\n  renderbuffer._height = height\n  renderbuffer._format = internalformat\n\n  var activeFramebuffer = this._activeFramebuffer\n  if (activeFramebuffer) {\n    var needsUpdate = false\n    for (var i = 0; i < ATTACHMENTS.length; ++i) {\n      if (activeFramebuffer._attachments[ATTACHMENTS[i]] === renderbuffer) {\n        needsUpdate = true\n      }\n    }\n    if (needsUpdate) {\n      updateFramebufferAttachments(this._activeFramebuffer)\n    }\n  }\n}\n\nvar _sampleCoverage = gl.sampleCoverage\ngl.sampleCoverage = function sampleCoverage (value, invert) {\n  return _sampleCoverage.call(this, +value, !!invert)\n}\n\nvar _scissor = gl.scissor\ngl.scissor = function scissor (x, y, width, height) {\n  return _scissor.call(this, x | 0, y | 0, width | 0, height | 0)\n}\n\nfunction wrapShader (type, source) {\n  return '#define gl_MaxDrawBuffers 1\\n' + source\n}\n\nvar _shaderSource = gl.shaderSource\ngl.shaderSource = function shaderSource (shader, source) {\n  if (!checkObject(shader)) {\n    throw new TypeError('shaderSource(WebGLShader, String)')\n  }\n  if (!shader || (!source && typeof source !== 'string')) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n  source += ''\n  if (!isValidString(source)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  } else if (checkWrapper(this, shader, WebGLShader)) {\n    _shaderSource.call(this, shader._ | 0, wrapShader(shader._type, source))\n    shader._source = source\n  }\n}\n\nvar _stencilFunc = gl.stencilFunc\ngl.stencilFunc = function stencilFunc (func, ref, mask) {\n  return _stencilFunc.call(this, func | 0, ref | 0, mask | 0)\n}\n\nvar _stencilFuncSeparate = gl.stencilFuncSeparate\ngl.stencilFuncSeparate = function stencilFuncSeparate (face, func, ref, mask) {\n  return _stencilFuncSeparate.call(this, face | 0, func | 0, ref | 0, mask | 0)\n}\n\nvar _stencilMask = gl.stencilMask\ngl.stencilMask = function stencilMask (mask) {\n  return _stencilMask.call(this, mask | 0)\n}\n\nvar _stencilMaskSeparate = gl.stencilMaskSeparate\ngl.stencilMaskSeparate = function stencilMaskSeparate (face, mask) {\n  return _stencilMaskSeparate.call(this, face | 0, mask | 0)\n}\n\nvar _stencilOp = gl.stencilOp\ngl.stencilOp = function stencilOp (fail, zfail, zpass) {\n  return _stencilOp.call(this, fail | 0, zfail | 0, zpass | 0)\n}\n\nvar _stencilOpSeparate = gl.stencilOpSeparate\ngl.stencilOpSeparate = function stencilOpSeparate (face, fail, zfail, zpass) {\n  return _stencilOpSeparate.call(this, face | 0, fail | 0, zfail | 0, zpass | 0)\n}\n\nfunction computePixelSize (context, type, internalformat) {\n  var pixelSize = formatSize(internalformat)\n  if (pixelSize === 0) {\n    setError(context, gl.INVALID_ENUM)\n    return 0\n  }\n  switch (type) {\n    case gl.UNSIGNED_BYTE:\n      return pixelSize\n    case gl.UNSIGNED_SHORT_5_6_5:\n      if (internalformat !== gl.RGB) {\n        setError(context, gl.INVALID_OPERATION)\n        break\n      }\n      return 2\n    case gl.UNSIGNED_SHORT_4_4_4_4:\n    case gl.UNSIGNED_SHORT_5_5_5_1:\n      if (internalformat !== gl.RGBA) {\n        setError(context, gl.INVALID_OPERATION)\n        break\n      }\n      return 2\n  }\n  setError(context, gl.INVALID_ENUM)\n  return 0\n}\n\nfunction checkDimensions (\n  context,\n  target,\n  width,\n  height,\n  level) {\n  if (level < 0 ||\n    width < 0 ||\n    height < 0) {\n    setError(context, gl.INVALID_VALUE)\n    return false\n  }\n  if (target === gl.TEXTURE_2D) {\n    if (width > context._maxTextureSize ||\n      height > context._maxTextureSize ||\n      level > context._maxTextureLevel) {\n      setError(context, gl.INVALID_VALUE)\n      return false\n    }\n  } else if (validCubeTarget(target)) {\n    if (width > context._maxCubeMapSize ||\n      height > context._maxCubeMapSize ||\n      level > context._maxCubeMapLevel) {\n      setError(context, gl.INVALID_VALUE)\n      return false\n    }\n  } else {\n    setError(context, gl.INVALID_ENUM)\n    return false\n  }\n  return true\n}\n\nfunction convertPixels (pixels) {\n  if (typeof pixels === 'object' && pixels !== null) {\n    if (pixels instanceof ArrayBuffer) {\n      return new Uint8Array(pixels)\n    } else if (pixels instanceof Uint8Array ||\n      pixels instanceof Uint16Array ||\n      pixels instanceof Uint8ClampedArray) {\n      return unpackTypedArray(pixels)\n    } else if (pixels instanceof Buffer) {\n      return new Uint8Array(pixels)\n    }\n  }\n  return null\n}\n\nfunction computeRowStride (context, width, pixelSize) {\n  var rowStride = width * pixelSize\n  if (rowStride % context._unpackAlignment) {\n    rowStride += context._unpackAlignment - (rowStride % context._unpackAlignment)\n  }\n  return rowStride\n}\n\nfunction checkFormat (format) {\n  return (\n    format === gl.ALPHA ||\n    format === gl.LUMINANCE_ALPHA ||\n    format === gl.LUMINANCE ||\n    format === gl.RGB ||\n    format === gl.RGBA)\n}\n\nvar _texImage2D = gl.texImage2D\ngl.texImage2D = function texImage2D (\n  target,\n  level,\n  internalformat,\n  width,\n  height,\n  border,\n  format,\n  type,\n  pixels) {\n  if (arguments.length === 6) {\n    pixels = border\n    type = height\n    format = width\n\n    if (typeof pixels !== 'object' || typeof pixels.data !== 'object') {\n      throw new TypeError('texImage2D(GLenum, GLint, GLenum, GLint, GLenum, GLenum, ImageData)')\n    }\n    width = pixels.width\n    height = pixels.height\n    pixels = pixels.data\n  }\n\n  target |= 0\n  level |= 0\n  internalformat |= 0\n  width |= 0\n  height |= 0\n  border |= 0\n  format |= 0\n  type |= 0\n\n  if (typeof pixels !== 'object' && pixels !== void 0) {\n    throw new TypeError('texImage2D(GLenum, GLint, GLenum, GLint, GLint, GLint, GLenum, GLenum, Uint8Array)')\n  }\n\n  if (!checkFormat(format) || !checkFormat(internalformat)) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  var texture = getTexImage(this, target)\n  if (!texture || format !== internalformat) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  var pixelSize = computePixelSize(this, type, format)\n  if (pixelSize === 0) {\n    return\n  }\n\n  if (!checkDimensions(\n      this,\n      target,\n      width,\n      height,\n      level)) {\n    return\n  }\n\n  var data = convertPixels(pixels)\n  var rowStride = computeRowStride(this, width, pixelSize)\n  var imageSize = rowStride * height\n\n  if (data && data.length < imageSize) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  if (border !== 0 ||\n    (validCubeTarget(target) && width !== height)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n  // Need to check for out of memory error\n  saveError(this)\n  _texImage2D.call(\n    this,\n    target,\n    level,\n    internalformat,\n    width,\n    height,\n    border,\n    format,\n    type,\n    data)\n  var error = this.getError()\n  restoreError(this, error)\n  if (error !== gl.NO_ERROR) {\n    return\n  }\n\n  // Save width and height at level\n  texture._levelWidth[level] = width\n  texture._levelHeight[level] = height\n  texture._format = format\n  texture._type = type\n\n  var activeFramebuffer = this._activeFramebuffer\n  if (activeFramebuffer) {\n    var needsUpdate = false\n    for (var i = 0; i < ATTACHMENTS.length; ++i) {\n      if (activeFramebuffer._attachments[ATTACHMENTS[i]] === texture) {\n        needsUpdate = true\n      }\n    }\n    if (needsUpdate) {\n      updateFramebufferAttachments(this._activeFramebuffer)\n    }\n  }\n}\n\nvar _texSubImage2D = gl.texSubImage2D\ngl.texSubImage2D = function texSubImage2D (\n  target,\n  level,\n  xoffset,\n  yoffset,\n  width,\n  height,\n  format,\n  type,\n  pixels) {\n  if (arguments.length === 7) {\n    pixels = format\n    type = height\n    format = width\n\n    if (typeof pixels !== 'object' || typeof pixels.data !== 'object') {\n      throw new TypeError('texSubImage2D(GLenum, GLint, GLint, GLint, GLenum, GLenum, ImageData)')\n    }\n    width = pixels.width\n    height = pixels.height\n    pixels = pixels.data\n  }\n\n  if (typeof pixels !== 'object') {\n    throw new TypeError('texSubImage2D(GLenum, GLint, GLint, GLint, GLint, GLint, GLenum, GLenum, Uint8Array)')\n  }\n\n  target |= 0\n  level |= 0\n  xoffset |= 0\n  yoffset |= 0\n  width |= 0\n  height |= 0\n  format |= 0\n  type |= 0\n\n  var texture = getTexImage(this, target)\n  if (!texture) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  var pixelSize = computePixelSize(this, type, format)\n  if (pixelSize === 0) {\n    return\n  }\n\n  if (!checkDimensions(\n      this,\n      target,\n      width,\n      height,\n      level)) {\n    return\n  }\n\n  if (xoffset < 0 || yoffset < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  var data = convertPixels(pixels)\n  var rowStride = computeRowStride(this, width, pixelSize)\n  var imageSize = rowStride * height\n\n  if (!data || data.length < imageSize) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  _texSubImage2D.call(\n    this,\n    target,\n    level,\n    xoffset,\n    yoffset,\n    width,\n    height,\n    format,\n    type,\n    data)\n}\n\nvar _texParameterf = gl.texParameterf\ngl.texParameterf = function texParameterf (target, pname, param) {\n  target |= 0\n  pname |= 0\n  param = +param\n  if (checkTextureTarget(this, target)) {\n    switch (pname) {\n      case gl.TEXTURE_MIN_FILTER:\n      case gl.TEXTURE_MAG_FILTER:\n      case gl.TEXTURE_WRAP_S:\n      case gl.TEXTURE_WRAP_T:\n        return _texParameterf.call(this, target, pname, param)\n    }\n\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n}\n\nvar _texParameteri = gl.texParameteri\ngl.texParameteri = function texParameteri (target, pname, param) {\n  target |= 0\n  pname |= 0\n  param |= 0\n  if (checkTextureTarget(this, target)) {\n    switch (pname) {\n      case gl.TEXTURE_MIN_FILTER:\n      case gl.TEXTURE_MAG_FILTER:\n      case gl.TEXTURE_WRAP_S:\n      case gl.TEXTURE_WRAP_T:\n        return _texParameterf.call(this, target, pname, param)\n    }\n\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n}\n\nfunction uniformTypeSize (type) {\n  switch (type) {\n    case gl.BOOL_VEC4:\n    case gl.INT_VEC4:\n    case gl.FLOAT_VEC4:\n      return 4\n\n    case gl.BOOL_VEC3:\n    case gl.INT_VEC3:\n    case gl.FLOAT_VEC3:\n      return 3\n\n    case gl.BOOL_VEC2:\n    case gl.INT_VEC2:\n    case gl.FLOAT_VEC2:\n      return 2\n\n    case gl.BOOL:\n    case gl.INT:\n    case gl.FLOAT:\n    case gl.SAMPLER_2D:\n    case gl.SAMPLER_CUBE:\n      return 1\n\n    default:\n      return 0\n  }\n}\n\n// Generate uniform binding code\nfunction makeUniforms () {\n  function makeMatrix (i) {\n    var func = 'uniformMatrix' + i + 'fv'\n    var native = gl[func]\n\n    gl[func] = function (location, transpose, v) {\n      if (!checkObject(location) ||\n        typeof v !== 'object') {\n        throw new TypeError(func + '(WebGLUniformLocation, Boolean, Array)')\n      } else if (!!transpose ||\n        typeof v !== 'object' ||\n        v === null ||\n        !v.length ||\n        v.length % i * i !== 0) {\n        setError(this, gl.INVALID_VALUE)\n        return\n      }\n      if (!location) {\n        return\n      }\n      if (!checkLocationActive(this, location)) {\n        return\n      }\n\n      var data = new Float32Array(v)\n      if (v.length === i * i) {\n        return native.call(this,\n          location._ | 0,\n          !!transpose,\n          data)\n      } else if (location._array) {\n        var arrayLocs = location._array\n        for (var j = 0; j < arrayLocs.length && (j + 1) * i * i <= v.length; ++j) {\n          native.call(this,\n            arrayLocs[j],\n            !!transpose,\n            new Float32Array(data.subarray(j * i * i, (j + 1) * i * i)))\n        }\n      } else {\n        setError(this, gl.INVALID_VALUE)\n        return\n      }\n    }\n  }\n\n  for (var n = 1; n <= 4; ++n) {\n    if (n > 1) {\n      makeMatrix(n)\n    }\n\n    ['i', 'f'].forEach(function (type) {\n      var i = n\n      var func = 'uniform' + i + type\n      var native = gl[func]\n\n      var base = gl[func] = function (location, x, y, z, w) {\n        if (!checkObject(location)) {\n          throw new TypeError(func + '(WebGLUniformLocation, ...)')\n        } else if (!location) {\n          return\n        } else if (checkLocationActive(this, location)) {\n          var utype = location._activeInfo.type\n          if (utype === gl.SAMPLER_2D ||\n            utype === gl.SAMPLER_CUBE) {\n            if (i !== 1) {\n              setError(this, gl.INVALID_VALUE)\n              return\n            }\n            if (type !== 'i') {\n              setError(this, gl.INVALID_OPERATION)\n              return\n            }\n            if (x < 0 || x >= this._textureUnits.length) {\n              setError(this, gl.INVALID_VALUE)\n              return\n            }\n          }\n          if (uniformTypeSize(utype) > i) {\n            setError(this, gl.INVALID_OPERATION)\n            return\n          }\n          return native.call(this, location._ | 0, x, y, z, w)\n        }\n      }\n\n      gl[func + 'v'] = function (location, v) {\n        if (!checkObject(location) ||\n          !checkObject(v)) {\n          throw new TypeError(func + 'v(WebGLUniformLocation, Array)')\n        } else if (!location) {\n          return\n        } else if (!checkLocationActive(this, location)) {\n          return\n        } else if (typeof v !== 'object' || !v || typeof v.length !== 'number') {\n          throw new TypeError('Second argument to ' + func + 'v must be array')\n        } else if (uniformTypeSize(location._activeInfo.type) > i) {\n          setError(this, gl.INVALID_OPERATION)\n          return\n        } else if (v.length >= i &&\n          v.length % i === 0) {\n          if (location._array) {\n            var arrayLocs = location._array\n            for (var j = 0; j < arrayLocs.length && (j + 1) * i <= v.length; ++j) {\n              var loc = arrayLocs[j]\n              switch (i) {\n                case 1:\n                  native.call(this, loc, v[i * j])\n                  break\n                case 2:\n                  native.call(this, loc, v[i * j], v[i * j + 1])\n                  break\n                case 3:\n                  native.call(this, loc, v[i * j], v[i * j + 1], v[i * j + 2])\n                  break\n                case 4:\n                  native.call(this, loc, v[i * j], v[i * j + 1], v[i * j + 2], v[i * j + 3])\n                  break\n              }\n            }\n            return\n          } else if (v.length === i) {\n            switch (i) {\n              case 1:\n                return base.call(this, location, v[0])\n              case 2:\n                return base.call(this, location, v[0], v[1])\n              case 3:\n                return base.call(this, location, v[0], v[1], v[2])\n              case 4:\n                return base.call(this, location, v[0], v[1], v[2], v[3])\n            }\n          } else {\n            setError(this, gl.INVALID_OPERATION)\n          }\n        }\n        setError(this, gl.INVALID_VALUE)\n      }\n    })\n  }\n}\nmakeUniforms()\n\nfunction switchActiveProgram (active) {\n  if (active) {\n    active._refCount -= 1\n    checkDelete(active)\n  }\n}\n\nvar _useProgram = gl.useProgram\ngl.useProgram = function useProgram (program) {\n  if (!checkObject(program)) {\n    throw new TypeError('useProgram(WebGLProgram)')\n  } else if (!program) {\n    switchActiveProgram(this._activeProgram)\n    this._activeProgram = null\n    return _useProgram.call(this, 0)\n  } else if (checkWrapper(this, program, WebGLProgram)) {\n    if (this._activeProgram !== program) {\n      switchActiveProgram(this._activeProgram)\n      this._activeProgram = program\n      program._refCount += 1\n    }\n    return _useProgram.call(this, program._ | 0)\n  }\n}\n\nvar _validateProgram = gl.validateProgram\ngl.validateProgram = function validateProgram (program) {\n  if (checkWrapper(this, program, WebGLProgram)) {\n    _validateProgram.call(this, program._ | 0)\n    var error = this.getError()\n    if (error === gl.NO_ERROR) {\n      program._linkInfoLog = _getProgramInfoLog.call(this, program._ | 0)\n    }\n    this.getError()\n    setError(this, error)\n  }\n}\n\nfunction makeVertexAttribs () {\n  function makeVertex (i) {\n    var func = 'vertexAttrib' + i + 'f'\n    var native = gl[func]\n\n    var base = gl[func] = function (idx, x, y, z, w) {\n      idx |= 0\n      if (idx < 0 || idx >= this._vertexAttribs.length) {\n        setError(this, gl.INVALID_VALUE)\n        return\n      }\n      var data = this._vertexAttribs[idx]._data\n      data[3] = 1\n      data[0] = data[1] = data[2] = 0.0\n      switch (i) {\n        case 4:\n          data[3] = w\n          data[2] = z\n          data[1] = y\n          data[0] = x\n          break\n        case 3:\n          data[2] = z\n          data[1] = y\n          data[0] = x\n          break\n        case 2:\n          data[1] = y\n          data[0] = x\n          break\n        case 1:\n          data[0] = x\n          break\n      }\n      return native.call(this, idx | 0, +x, +y, +z, +w)\n    }\n\n    gl[func + 'v'] = function (idx, v) {\n      if (typeof v === 'object' &&\n        v !== null &&\n        v.length >= i) {\n        switch (i) {\n          case 1:\n            return base.call(this, idx | 0, +v[0], 0, 0, 0)\n          case 2:\n            return base.call(this, idx | 0, +v[0], +v[1], 0, 0)\n          case 3:\n            return base.call(this, idx | 0, +v[0], +v[1], +v[2], 0)\n          case 4:\n            return base.call(this, idx | 0, +v[0], +v[1], +v[2], +v[3])\n        }\n      }\n      setError(this, gl.INVALID_OPERATION)\n    }\n  }\n  for (var n = 1; n <= 4; ++n) makeVertex(n)\n}\nmakeVertexAttribs()\n\nvar _vertexAttribPointer = gl.vertexAttribPointer\ngl.vertexAttribPointer = function vertexAttribPointer (\n  index,\n  size,\n  type,\n  normalized,\n  stride,\n  offset) {\n  if (stride < 0 || offset < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  index |= 0\n  size |= 0\n  type |= 0\n  normalized = !!normalized\n  stride |= 0\n  offset |= 0\n\n  if (stride < 0 ||\n    offset < 0 ||\n    index < 0 || index >= this._vertexAttribs.length ||\n    !(size === 1 || size === 2 || size === 3 || size === 4)) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  if (this._activeArrayBuffer === null) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  // fixed, int and unsigned int aren't allowed in WebGL\n  var byteSize = typeSize(type)\n  if (byteSize === 0 ||\n    type === gl.INT ||\n    type === gl.UNSIGNED_INT) {\n    setError(this, gl.INVALID_ENUM)\n    return\n  }\n\n  if (stride > 255 || stride < 0) {\n    setError(this, gl.INVALID_VALUE)\n    return\n  }\n\n  // stride and offset must be multiples of size\n  if ((stride % byteSize) !== 0 ||\n    (offset % byteSize) !== 0) {\n    setError(this, gl.INVALID_OPERATION)\n    return\n  }\n\n  // Call vertex attrib pointer\n  _vertexAttribPointer.call(this, index, size, type, normalized, stride, offset)\n\n  // Save attribute pointer state\n  var attrib = this._vertexAttribs[index]\n\n  if (attrib._pointerBuffer &&\n    attrib._pointerBuffer !== this._activeArrayBuffer) {\n    attrib._pointerBuffer._refCount -= 1\n    checkDelete(attrib._pointerBuffer)\n  }\n\n  this._activeArrayBuffer._refCount += 1\n  attrib._pointerBuffer = this._activeArrayBuffer\n  attrib._pointerSize = size * byteSize\n  attrib._pointerOffset = offset\n  attrib._pointerStride = stride || (size * byteSize)\n  attrib._pointerType = type\n  attrib._pointerNormal = normalized\n  attrib._inputStride = stride\n  attrib._inputSize = size\n}\n\nvar _viewport = gl.viewport\ngl.viewport = function viewport (x, y, width, height) {\n  return _viewport.call(this, x | 0, y | 0, width | 0, height | 0)\n}\n\nfunction allocateDrawingBuffer (context, width, height) {\n  context._drawingBuffer = new WebGLDrawingBufferWrapper(\n    _createFramebuffer.call(context),\n    _createTexture.call(context),\n    _createRenderbuffer.call(context))\n\n  resizeDrawingBuffer(context, width, height)\n}\n\nexports.allocateDrawingBuffer = allocateDrawingBuffer\n\nfunction resizeDrawingBuffer (context, width, height) {\n  var prevFramebuffer = context._activeFramebuffer\n  var prevTexture = activeTexture(context, gl.TEXTURE_2D)\n  var prevRenderbuffer = context._activeRenderbuffer\n\n  var contextAttributes = context._contextattributes\n\n  var drawingBuffer = context._drawingBuffer\n  _bindFramebuffer.call(context, gl.FRAMEBUFFER, drawingBuffer._framebuffer)\n\n  // Clear all attachments\n  for (var i = 0; i < ATTACHMENTS.length; ++i) {\n    _framebufferTexture2D.call(\n      context,\n      gl.FRAMEBUFFER,\n      ATTACHMENTS[i],\n      gl.TEXTURE_2D,\n      0,\n      0)\n  }\n\n  // Update color attachment\n  _bindTexture.call(\n    context,\n    gl.TEXTURE_2D,\n    drawingBuffer._color)\n  var colorFormat = contextAttributes.alpha ? gl.RGBA : gl.RGB\n  _texImage2D.call(\n    context,\n    gl.TEXTURE_2D,\n    0,\n    colorFormat,\n    width,\n    height,\n    0,\n    colorFormat,\n    gl.UNSIGNED_BYTE,\n    null)\n  _texParameteri.call(context, gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n  _texParameteri.call(context, gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n  _framebufferTexture2D.call(\n    context,\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    drawingBuffer._color,\n    0)\n\n  // Update depth-stencil attachments if needed\n  var storage = 0\n  var attachment = 0\n  if (contextAttributes.depth && contextAttributes.stencil) {\n    storage = gl.DEPTH_STENCIL\n    attachment = gl.DEPTH_STENCIL_ATTACHMENT\n  } else if (contextAttributes.depth) {\n    storage = 0x81A7\n    attachment = gl.DEPTH_ATTACHMENT\n  } else if (contextAttributes.stencil) {\n    storage = gl.STENCIL_INDEX8\n    attachment = gl.STENCIL_ATTACHMENT\n  }\n\n  if (storage) {\n    _bindRenderbuffer.call(\n      context,\n      gl.RENDERBUFFER,\n      drawingBuffer._depthStencil)\n    _renderbufferStorage.call(\n      context,\n      gl.RENDERBUFFER,\n      storage,\n      width,\n      height)\n    _framebufferRenderbuffer.call(\n      context,\n      gl.FRAMEBUFFER,\n      attachment,\n      gl.RENDERBUFFER,\n      drawingBuffer._depthStencil)\n  }\n\n  // Restore previous binding state\n  context.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer)\n  context.bindTexture(gl.TEXTURE_2D, prevTexture)\n  context.bindRenderbuffer(gl.RENDERBUFFER, prevRenderbuffer)\n}\n\ngl.isContextLost = function () {\n  return false\n}\n\ngl.compressedTexImage2D = function () {\n  // TODO not yet implemented\n}\n\ngl.compressedTexSubImage2D = function () {\n  // TODO not yet implemented\n}\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/string.js":"var tokenize = require('./index')\n\nmodule.exports = tokenizeString\n\nfunction tokenizeString(str, opt) {\n  var generator = tokenize(opt)\n  var tokens = []\n\n  tokens = tokens.concat(generator(str))\n  tokens = tokens.concat(generator(null))\n\n  return tokens\n}\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/index.js":"module.exports = tokenize\n\nvar literals100 = require('./lib/literals')\n  , operators = require('./lib/operators')\n  , builtins100 = require('./lib/builtins')\n  , literals300es = require('./lib/literals-300es')\n  , builtins300es = require('./lib/builtins-300es')\n\nvar NORMAL = 999          // <-- never emitted\n  , TOKEN = 9999          // <-- never emitted\n  , BLOCK_COMMENT = 0\n  , LINE_COMMENT = 1\n  , PREPROCESSOR = 2\n  , OPERATOR = 3\n  , INTEGER = 4\n  , FLOAT = 5\n  , IDENT = 6\n  , BUILTIN = 7\n  , KEYWORD = 8\n  , WHITESPACE = 9\n  , EOF = 10\n  , HEX = 11\n\nvar map = [\n    'block-comment'\n  , 'line-comment'\n  , 'preprocessor'\n  , 'operator'\n  , 'integer'\n  , 'float'\n  , 'ident'\n  , 'builtin'\n  , 'keyword'\n  , 'whitespace'\n  , 'eof'\n  , 'integer'\n]\n\nfunction tokenize(opt) {\n  var i = 0\n    , total = 0\n    , mode = NORMAL\n    , c\n    , last\n    , content = []\n    , tokens = []\n    , token_idx = 0\n    , token_offs = 0\n    , line = 1\n    , col = 0\n    , start = 0\n    , isnum = false\n    , isoperator = false\n    , input = ''\n    , len\n\n  opt = opt || {}\n  var allBuiltins = builtins100\n  var allLiterals = literals100\n  if (opt.version === '300 es') {\n    allBuiltins = builtins300es\n    allLiterals = literals300es\n  }\n\n  return function(data) {\n    tokens = []\n    if (data !== null) return write(data.replace ? data.replace(/\\r\\n/g, '\\n') : data)\n    return end()\n  }\n\n  function token(data) {\n    if (data.length) {\n      tokens.push({\n        type: map[mode]\n      , data: data\n      , position: start\n      , line: line\n      , column: col\n      })\n    }\n  }\n\n  function write(chunk) {\n    i = 0\n    input += chunk\n    len = input.length\n\n    var last\n\n    while(c = input[i], i < len) {\n      last = i\n\n      switch(mode) {\n        case BLOCK_COMMENT: i = block_comment(); break\n        case LINE_COMMENT: i = line_comment(); break\n        case PREPROCESSOR: i = preprocessor(); break\n        case OPERATOR: i = operator(); break\n        case INTEGER: i = integer(); break\n        case HEX: i = hex(); break\n        case FLOAT: i = decimal(); break\n        case TOKEN: i = readtoken(); break\n        case WHITESPACE: i = whitespace(); break\n        case NORMAL: i = normal(); break\n      }\n\n      if(last !== i) {\n        switch(input[last]) {\n          case '\\n': col = 0; ++line; break\n          default: ++col; break\n        }\n      }\n    }\n\n    total += i\n    input = input.slice(i)\n    return tokens\n  }\n\n  function end(chunk) {\n    if(content.length) {\n      token(content.join(''))\n    }\n\n    mode = EOF\n    token('(eof)')\n    return tokens\n  }\n\n  function normal() {\n    content = content.length ? [] : content\n\n    if(last === '/' && c === '*') {\n      start = total + i - 1\n      mode = BLOCK_COMMENT\n      last = c\n      return i + 1\n    }\n\n    if(last === '/' && c === '/') {\n      start = total + i - 1\n      mode = LINE_COMMENT\n      last = c\n      return i + 1\n    }\n\n    if(c === '#') {\n      mode = PREPROCESSOR\n      start = total + i\n      return i\n    }\n\n    if(/\\s/.test(c)) {\n      mode = WHITESPACE\n      start = total + i\n      return i\n    }\n\n    isnum = /\\d/.test(c)\n    isoperator = /[^\\w_]/.test(c)\n\n    start = total + i\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\n    return i\n  }\n\n  function whitespace() {\n    if(/[^\\s]/g.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function preprocessor() {\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function line_comment() {\n    return preprocessor()\n  }\n\n  function block_comment() {\n    if(c === '/' && last === '*') {\n      content.push(c)\n      token(content.join(''))\n      mode = NORMAL\n      return i + 1\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function operator() {\n    if(last === '.' && /\\d/.test(c)) {\n      mode = FLOAT\n      return i\n    }\n\n    if(last === '/' && c === '*') {\n      mode = BLOCK_COMMENT\n      return i\n    }\n\n    if(last === '/' && c === '/') {\n      mode = LINE_COMMENT\n      return i\n    }\n\n    if(c === '.' && content.length) {\n      while(determine_operator(content));\n\n      mode = FLOAT\n      return i\n    }\n\n    if(c === ';' || c === ')' || c === '(') {\n      if(content.length) while(determine_operator(content));\n      token(c)\n      mode = NORMAL\n      return i + 1\n    }\n\n    var is_composite_operator = content.length === 2 && c !== '='\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\n      while(determine_operator(content));\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function determine_operator(buf) {\n    var j = 0\n      , idx\n      , res\n\n    do {\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\n      res = operators[idx]\n\n      if(idx === -1) {\n        if(j-- + buf.length > 0) continue\n        res = buf.slice(0, 1).join('')\n      }\n\n      token(res)\n\n      start += res.length\n      content = content.slice(res.length)\n      return content.length\n    } while(1)\n  }\n\n  function hex() {\n    if(/[^a-fA-F0-9]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function integer() {\n    if(c === '.') {\n      content.push(c)\n      mode = FLOAT\n      last = c\n      return i + 1\n    }\n\n    if(/[eE]/.test(c)) {\n      content.push(c)\n      mode = FLOAT\n      last = c\n      return i + 1\n    }\n\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\n      mode = HEX\n      content.push(c)\n      last = c\n      return i + 1\n    }\n\n    if(/[^\\d]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function decimal() {\n    if(c === 'f') {\n      content.push(c)\n      last = c\n      i += 1\n    }\n\n    if(/[eE]/.test(c)) {\n      content.push(c)\n      last = c\n      return i + 1\n    }\n\n    if (c === '-' && /[eE]/.test(last)) {\n      content.push(c)\n      last = c\n      return i + 1\n    }\n\n    if(/[^\\d]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function readtoken() {\n    if(/[^\\d\\w_]/.test(c)) {\n      var contentstr = content.join('')\n      if(allLiterals.indexOf(contentstr) > -1) {\n        mode = KEYWORD\n      } else if(allBuiltins.indexOf(contentstr) > -1) {\n        mode = BUILTIN\n      } else {\n        mode = IDENT\n      }\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/lib/literals.js":"module.exports = [\n  // current\n    'precision'\n  , 'highp'\n  , 'mediump'\n  , 'lowp'\n  , 'attribute'\n  , 'const'\n  , 'uniform'\n  , 'varying'\n  , 'break'\n  , 'continue'\n  , 'do'\n  , 'for'\n  , 'while'\n  , 'if'\n  , 'else'\n  , 'in'\n  , 'out'\n  , 'inout'\n  , 'float'\n  , 'int'\n  , 'void'\n  , 'bool'\n  , 'true'\n  , 'false'\n  , 'discard'\n  , 'return'\n  , 'mat2'\n  , 'mat3'\n  , 'mat4'\n  , 'vec2'\n  , 'vec3'\n  , 'vec4'\n  , 'ivec2'\n  , 'ivec3'\n  , 'ivec4'\n  , 'bvec2'\n  , 'bvec3'\n  , 'bvec4'\n  , 'sampler1D'\n  , 'sampler2D'\n  , 'sampler3D'\n  , 'samplerCube'\n  , 'sampler1DShadow'\n  , 'sampler2DShadow'\n  , 'struct'\n\n  // future\n  , 'asm'\n  , 'class'\n  , 'union'\n  , 'enum'\n  , 'typedef'\n  , 'template'\n  , 'this'\n  , 'packed'\n  , 'goto'\n  , 'switch'\n  , 'default'\n  , 'inline'\n  , 'noinline'\n  , 'volatile'\n  , 'public'\n  , 'static'\n  , 'extern'\n  , 'external'\n  , 'interface'\n  , 'long'\n  , 'short'\n  , 'double'\n  , 'half'\n  , 'fixed'\n  , 'unsigned'\n  , 'input'\n  , 'output'\n  , 'hvec2'\n  , 'hvec3'\n  , 'hvec4'\n  , 'dvec2'\n  , 'dvec3'\n  , 'dvec4'\n  , 'fvec2'\n  , 'fvec3'\n  , 'fvec4'\n  , 'sampler2DRect'\n  , 'sampler3DRect'\n  , 'sampler2DRectShadow'\n  , 'sizeof'\n  , 'cast'\n  , 'namespace'\n  , 'using'\n]\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/lib/operators.js":"module.exports = [\n    '<<='\n  , '>>='\n  , '++'\n  , '--'\n  , '<<'\n  , '>>'\n  , '<='\n  , '>='\n  , '=='\n  , '!='\n  , '&&'\n  , '||'\n  , '+='\n  , '-='\n  , '*='\n  , '/='\n  , '%='\n  , '&='\n  , '^^'\n  , '^='\n  , '|='\n  , '('\n  , ')'\n  , '['\n  , ']'\n  , '.'\n  , '!'\n  , '~'\n  , '*'\n  , '/'\n  , '%'\n  , '+'\n  , '-'\n  , '<'\n  , '>'\n  , '&'\n  , '^'\n  , '|'\n  , '?'\n  , ':'\n  , '='\n  , ','\n  , ';'\n  , '{'\n  , '}'\n]\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/lib/builtins.js":"module.exports = [\n  // Keep this list sorted\n  'abs'\n  , 'acos'\n  , 'all'\n  , 'any'\n  , 'asin'\n  , 'atan'\n  , 'ceil'\n  , 'clamp'\n  , 'cos'\n  , 'cross'\n  , 'dFdx'\n  , 'dFdy'\n  , 'degrees'\n  , 'distance'\n  , 'dot'\n  , 'equal'\n  , 'exp'\n  , 'exp2'\n  , 'faceforward'\n  , 'floor'\n  , 'fract'\n  , 'gl_BackColor'\n  , 'gl_BackLightModelProduct'\n  , 'gl_BackLightProduct'\n  , 'gl_BackMaterial'\n  , 'gl_BackSecondaryColor'\n  , 'gl_ClipPlane'\n  , 'gl_ClipVertex'\n  , 'gl_Color'\n  , 'gl_DepthRange'\n  , 'gl_DepthRangeParameters'\n  , 'gl_EyePlaneQ'\n  , 'gl_EyePlaneR'\n  , 'gl_EyePlaneS'\n  , 'gl_EyePlaneT'\n  , 'gl_Fog'\n  , 'gl_FogCoord'\n  , 'gl_FogFragCoord'\n  , 'gl_FogParameters'\n  , 'gl_FragColor'\n  , 'gl_FragCoord'\n  , 'gl_FragData'\n  , 'gl_FragDepth'\n  , 'gl_FragDepthEXT'\n  , 'gl_FrontColor'\n  , 'gl_FrontFacing'\n  , 'gl_FrontLightModelProduct'\n  , 'gl_FrontLightProduct'\n  , 'gl_FrontMaterial'\n  , 'gl_FrontSecondaryColor'\n  , 'gl_LightModel'\n  , 'gl_LightModelParameters'\n  , 'gl_LightModelProducts'\n  , 'gl_LightProducts'\n  , 'gl_LightSource'\n  , 'gl_LightSourceParameters'\n  , 'gl_MaterialParameters'\n  , 'gl_MaxClipPlanes'\n  , 'gl_MaxCombinedTextureImageUnits'\n  , 'gl_MaxDrawBuffers'\n  , 'gl_MaxFragmentUniformComponents'\n  , 'gl_MaxLights'\n  , 'gl_MaxTextureCoords'\n  , 'gl_MaxTextureImageUnits'\n  , 'gl_MaxTextureUnits'\n  , 'gl_MaxVaryingFloats'\n  , 'gl_MaxVertexAttribs'\n  , 'gl_MaxVertexTextureImageUnits'\n  , 'gl_MaxVertexUniformComponents'\n  , 'gl_ModelViewMatrix'\n  , 'gl_ModelViewMatrixInverse'\n  , 'gl_ModelViewMatrixInverseTranspose'\n  , 'gl_ModelViewMatrixTranspose'\n  , 'gl_ModelViewProjectionMatrix'\n  , 'gl_ModelViewProjectionMatrixInverse'\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\n  , 'gl_ModelViewProjectionMatrixTranspose'\n  , 'gl_MultiTexCoord0'\n  , 'gl_MultiTexCoord1'\n  , 'gl_MultiTexCoord2'\n  , 'gl_MultiTexCoord3'\n  , 'gl_MultiTexCoord4'\n  , 'gl_MultiTexCoord5'\n  , 'gl_MultiTexCoord6'\n  , 'gl_MultiTexCoord7'\n  , 'gl_Normal'\n  , 'gl_NormalMatrix'\n  , 'gl_NormalScale'\n  , 'gl_ObjectPlaneQ'\n  , 'gl_ObjectPlaneR'\n  , 'gl_ObjectPlaneS'\n  , 'gl_ObjectPlaneT'\n  , 'gl_Point'\n  , 'gl_PointCoord'\n  , 'gl_PointParameters'\n  , 'gl_PointSize'\n  , 'gl_Position'\n  , 'gl_ProjectionMatrix'\n  , 'gl_ProjectionMatrixInverse'\n  , 'gl_ProjectionMatrixInverseTranspose'\n  , 'gl_ProjectionMatrixTranspose'\n  , 'gl_SecondaryColor'\n  , 'gl_TexCoord'\n  , 'gl_TextureEnvColor'\n  , 'gl_TextureMatrix'\n  , 'gl_TextureMatrixInverse'\n  , 'gl_TextureMatrixInverseTranspose'\n  , 'gl_TextureMatrixTranspose'\n  , 'gl_Vertex'\n  , 'greaterThan'\n  , 'greaterThanEqual'\n  , 'inversesqrt'\n  , 'length'\n  , 'lessThan'\n  , 'lessThanEqual'\n  , 'log'\n  , 'log2'\n  , 'matrixCompMult'\n  , 'max'\n  , 'min'\n  , 'mix'\n  , 'mod'\n  , 'normalize'\n  , 'not'\n  , 'notEqual'\n  , 'pow'\n  , 'radians'\n  , 'reflect'\n  , 'refract'\n  , 'sign'\n  , 'sin'\n  , 'smoothstep'\n  , 'sqrt'\n  , 'step'\n  , 'tan'\n  , 'texture2D'\n  , 'texture2DLod'\n  , 'texture2DProj'\n  , 'texture2DProjLod'\n  , 'textureCube'\n  , 'textureCubeLod'\n  , 'texture2DLodEXT'\n  , 'texture2DProjLodEXT'\n  , 'textureCubeLodEXT'\n  , 'texture2DGradEXT'\n  , 'texture2DProjGradEXT'\n  , 'textureCubeGradEXT'\n]\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/lib/literals-300es.js":"var v100 = require('./literals')\n\nmodule.exports = v100.slice().concat([\n   'layout'\n  , 'centroid'\n  , 'smooth'\n  , 'case'\n  , 'mat2x2'\n  , 'mat2x3'\n  , 'mat2x4'\n  , 'mat3x2'\n  , 'mat3x3'\n  , 'mat3x4'\n  , 'mat4x2'\n  , 'mat4x3'\n  , 'mat4x4'\n  , 'uint'\n  , 'uvec2'\n  , 'uvec3'\n  , 'uvec4'\n  , 'samplerCubeShadow'\n  , 'sampler2DArray'\n  , 'sampler2DArrayShadow'\n  , 'isampler2D'\n  , 'isampler3D'\n  , 'isamplerCube'\n  , 'isampler2DArray'\n  , 'usampler2D'\n  , 'usampler3D'\n  , 'usamplerCube'\n  , 'usampler2DArray'\n  , 'coherent'\n  , 'restrict'\n  , 'readonly'\n  , 'writeonly'\n  , 'resource'\n  , 'atomic_uint'\n  , 'noperspective'\n  , 'patch'\n  , 'sample'\n  , 'subroutine'\n  , 'common'\n  , 'partition'\n  , 'active'\n  , 'filter'\n  , 'image1D'\n  , 'image2D'\n  , 'image3D'\n  , 'imageCube'\n  , 'iimage1D'\n  , 'iimage2D'\n  , 'iimage3D'\n  , 'iimageCube'\n  , 'uimage1D'\n  , 'uimage2D'\n  , 'uimage3D'\n  , 'uimageCube'\n  , 'image1DArray'\n  , 'image2DArray'\n  , 'iimage1DArray'\n  , 'iimage2DArray'\n  , 'uimage1DArray'\n  , 'uimage2DArray'\n  , 'image1DShadow'\n  , 'image2DShadow'\n  , 'image1DArrayShadow'\n  , 'image2DArrayShadow'\n  , 'imageBuffer'\n  , 'iimageBuffer'\n  , 'uimageBuffer'\n  , 'sampler1DArray'\n  , 'sampler1DArrayShadow'\n  , 'isampler1D'\n  , 'isampler1DArray'\n  , 'usampler1D'\n  , 'usampler1DArray'\n  , 'isampler2DRect'\n  , 'usampler2DRect'\n  , 'samplerBuffer'\n  , 'isamplerBuffer'\n  , 'usamplerBuffer'\n  , 'sampler2DMS'\n  , 'isampler2DMS'\n  , 'usampler2DMS'\n  , 'sampler2DMSArray'\n  , 'isampler2DMSArray'\n  , 'usampler2DMSArray'\n])\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/glsl-tokenizer/lib/builtins-300es.js":"// 300es builtins/reserved words that were previously valid in v100\nvar v100 = require('./builtins')\n\n// The texture2D|Cube functions have been removed\n// And the gl_ features are updated\nv100 = v100.slice().filter(function (b) {\n  return !/^(gl\\_|texture)/.test(b)\n})\n\nmodule.exports = v100.concat([\n  // the updated gl_ constants\n    'gl_VertexID'\n  , 'gl_InstanceID'\n  , 'gl_Position'\n  , 'gl_PointSize'\n  , 'gl_FragCoord'\n  , 'gl_FrontFacing'\n  , 'gl_FragDepth'\n  , 'gl_PointCoord'\n  , 'gl_MaxVertexAttribs'\n  , 'gl_MaxVertexUniformVectors'\n  , 'gl_MaxVertexOutputVectors'\n  , 'gl_MaxFragmentInputVectors'\n  , 'gl_MaxVertexTextureImageUnits'\n  , 'gl_MaxCombinedTextureImageUnits'\n  , 'gl_MaxTextureImageUnits'\n  , 'gl_MaxFragmentUniformVectors'\n  , 'gl_MaxDrawBuffers'\n  , 'gl_MinProgramTexelOffset'\n  , 'gl_MaxProgramTexelOffset'\n  , 'gl_DepthRangeParameters'\n  , 'gl_DepthRange'\n\n  // other builtins\n  , 'trunc'\n  , 'round'\n  , 'roundEven'\n  , 'isnan'\n  , 'isinf'\n  , 'floatBitsToInt'\n  , 'floatBitsToUint'\n  , 'intBitsToFloat'\n  , 'uintBitsToFloat'\n  , 'packSnorm2x16'\n  , 'unpackSnorm2x16'\n  , 'packUnorm2x16'\n  , 'unpackUnorm2x16'\n  , 'packHalf2x16'\n  , 'unpackHalf2x16'\n  , 'outerProduct'\n  , 'transpose'\n  , 'determinant'\n  , 'inverse'\n  , 'texture'\n  , 'textureSize'\n  , 'textureProj'\n  , 'textureLod'\n  , 'textureOffset'\n  , 'texelFetch'\n  , 'texelFetchOffset'\n  , 'textureProjOffset'\n  , 'textureLodOffset'\n  , 'textureProjLod'\n  , 'textureProjLodOffset'\n  , 'textureGrad'\n  , 'textureGradOffset'\n  , 'textureProjGrad'\n  , 'textureProjGradOffset'\n])\n","/home/travis/build/npmtest/node-npmtest-gl/node_modules/gl/wrap.js":"var webgl = require('./webgl')\n\nvar privateMethods = [\n  'resize',\n  'destroy'\n]\n\nmodule.exports = function wrapContext (gl) {\n  var props = Object.keys(gl).concat(Object.keys(gl.constructor.prototype))\n  var wrapper = new WebGLRenderingContext()\n\n  props.forEach(function (prop) {\n    if (prop[0] === '_' ||\n        prop[0] === '0' ||\n        prop[0] === '1') {\n      return\n    }\n    var value = gl[prop]\n    if (typeof value === 'function') {\n      if (privateMethods.indexOf(value) < 0) {\n        wrapper[prop] = value.bind(gl)\n      }\n    } else {\n      wrapper[prop] = value\n    }\n  })\n\n  Object.defineProperties(wrapper, {\n    drawingBufferWidth: {\n      get: function () { return gl.drawingBufferWidth }\n    },\n    drawingBufferHeight: {\n      get: function () { return gl.drawingBufferHeight }\n    }\n  })\n\n  return wrapper\n}\n\nfunction WebGLRenderingContext () {}\nmodule.exports.WebGLRenderingContext = WebGLRenderingContext\n\n// FIXME: Wrap all these objects to prevent headless-gl stuff from leaking\nmodule.exports.WebGLProgram = webgl.WebGLProgram\nmodule.exports.WebGLShader = webgl.WebGLShader\nmodule.exports.WebGLBuffer = webgl.WebGLBuffer\nmodule.exports.WebGLFramebuffer = webgl.WebGLFramebuffer\nmodule.exports.WebGLRenderbuffer = webgl.WebGLRenderbuffer\nmodule.exports.WebGLTexture = webgl.WebGLTexture\nmodule.exports.WebGLUniformLocation = webgl.WebGLUniformLocation\nmodule.exports.WebGLActiveInfo = webgl.WebGLActiveInfo\nmodule.exports.WebGLShaderPrecisionFormat = webgl.WebGLShaderPrecisionFormat\n"}